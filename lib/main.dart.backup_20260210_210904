import 'package:flutter/material.dart';
import 'package:flutter/scheduler.dart';
import 'dart:async';
import 'dart:math';
import 'dart:convert';
import 'dart:io';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:flutter/services.dart';
import 'package:path_provider/path_provider.dart';
import 'package:flutter/foundation.dart';
import 'package:vibration/vibration.dart';
import 'app_update_manager.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'firebase_options.dart';
import 'package:device_info_plus/device_info_plus.dart';
import 'package:share_plus/share_plus.dart';
import 'dart:math' show Random, min;

// Global session ID - will be generated or loaded from shared link
String TIMER_SESSION_ID = 'default_session';

/// Comprehensive haptic feedback function with multiple fallbacks for Android compatibility
Future<void> performHapticFeedback() async {
  if (kDebugMode) {
    print('üîî Attempting haptic feedback on ${defaultTargetPlatform}');
  }

  try {
    // Method 1: For Android, use the vibration plugin first (most reliable)
    if (defaultTargetPlatform == TargetPlatform.android) {
      bool? hasVibrator = await Vibration.hasVibrator();
      if (kDebugMode) print('üì± Device has vibrator: $hasVibrator');

      if (hasVibrator == true) {
        try {
          // Check if amplitude control is supported
          bool? hasAmplitudeControl = await Vibration.hasAmplitudeControl();
          if (kDebugMode)
            print('üéõÔ∏è Amplitude control support: $hasAmplitudeControl');

          if (hasAmplitudeControl == true) {
            // Use amplitude-controlled vibration
            await Vibration.vibrate(duration: 100, amplitude: 128);
            if (kDebugMode) print('‚úÖ Amplitude vibration succeeded');
            return;
          } else {
            // Fallback to simple vibration
            await Vibration.vibrate(duration: 100);
            if (kDebugMode) print('‚úÖ Simple vibration succeeded');
            return;
          }
        } catch (e) {
          if (kDebugMode) print('‚ùå Vibration plugin failed: $e');
          // Continue to next method
        }
      } else {
        if (kDebugMode) print('‚ùå No vibrator available on device');
      }
    }

    // Method 2: Try Flutter's built-in haptic feedback (iOS and Android fallback)
    if (defaultTargetPlatform == TargetPlatform.iOS) {
      await HapticFeedback.mediumImpact();
      if (kDebugMode) print('‚úÖ iOS haptic feedback succeeded');
      return;
    }

    // Method 3: For Android fallback, try Flutter's haptic feedback
    if (defaultTargetPlatform == TargetPlatform.android) {
      try {
        await HapticFeedback.mediumImpact();
        if (kDebugMode) print('‚úÖ Android Flutter mediumImpact succeeded');
        return;
      } catch (e1) {
        if (kDebugMode) print('‚ùå mediumImpact failed: $e1');
        try {
          await HapticFeedback.lightImpact();
          if (kDebugMode) print('‚úÖ Android lightImpact succeeded');
          return;
        } catch (e2) {
          if (kDebugMode) print('‚ùå lightImpact failed: $e2');
          try {
            await HapticFeedback.heavyImpact();
            if (kDebugMode) print('‚úÖ Android heavyImpact succeeded');
            return;
          } catch (e3) {
            if (kDebugMode) print('‚ùå heavyImpact failed: $e3');
            try {
              await HapticFeedback.selectionClick();
              if (kDebugMode) print('‚úÖ Android selectionClick succeeded');
              return;
            } catch (e4) {
              if (kDebugMode) print('‚ùå selectionClick failed: $e4');
              // Method 4: Manual vibration using platform channel
              await _manualVibration();
            }
          }
        }
      }
    }
  } catch (e) {
    // If all methods fail, print debug info but don't crash
    if (kDebugMode) {
      print('‚ùå All haptic feedback methods failed: $e');
    }
  }
}

/// Manual vibration using platform channel as ultimate fallback
Future<void> _manualVibration() async {
  try {
    if (kDebugMode)
      print('üîß Attempting manual vibration via platform channel');
    const platform = MethodChannel('flutter/haptic_feedback');
    await platform.invokeMethod('vibrate', {'duration': 50});
    if (kDebugMode) print('‚úÖ Manual vibration succeeded');
  } catch (e) {
    if (kDebugMode) {
      print('‚ùå Manual vibration failed: $e');
    }
  }
}

/// Test method to specifically debug haptic feedback issues
Future<void> testAllHapticMethods() async {
  if (kDebugMode) {
    print('üß™ HAPTIC TEST: Starting comprehensive haptic feedback test');
    print('üì± Platform: ${defaultTargetPlatform}');
  }

  // Test 1: Vibration plugin - hasVibrator check
  try {
    bool? hasVibrator = await Vibration.hasVibrator();
    if (kDebugMode) print('üß™ TEST 1 - hasVibrator(): $hasVibrator');
  } catch (e) {
    if (kDebugMode) print('üß™ TEST 1 - hasVibrator() ERROR: $e');
  }

  // Test 2: Vibration plugin - amplitude control check
  try {
    bool? hasAmplitudeControl = await Vibration.hasAmplitudeControl();
    if (kDebugMode)
      print('üß™ TEST 2 - hasAmplitudeControl(): $hasAmplitudeControl');
  } catch (e) {
    if (kDebugMode) print('üß™ TEST 2 - hasAmplitudeControl() ERROR: $e');
  }

  // Test 3: Simple vibration
  try {
    await Vibration.vibrate(duration: 100);
    if (kDebugMode) print('üß™ TEST 3 - Simple vibrate(100ms): SUCCESS');
    await Future.delayed(Duration(milliseconds: 200));
  } catch (e) {
    if (kDebugMode) print('üß™ TEST 3 - Simple vibrate(100ms) ERROR: $e');
  }

  // Test 4: Amplitude vibration (if supported)
  try {
    await Vibration.vibrate(duration: 100, amplitude: 128);
    if (kDebugMode) print('üß™ TEST 4 - Amplitude vibrate(100ms, 128): SUCCESS');
    await Future.delayed(Duration(milliseconds: 200));
  } catch (e) {
    if (kDebugMode)
      print('üß™ TEST 4 - Amplitude vibrate(100ms, 128) ERROR: $e');
  }

  // Test 5: Flutter's HapticFeedback.mediumImpact
  try {
    await HapticFeedback.mediumImpact();
    if (kDebugMode) print('üß™ TEST 5 - HapticFeedback.mediumImpact(): SUCCESS');
    await Future.delayed(Duration(milliseconds: 200));
  } catch (e) {
    if (kDebugMode)
      print('üß™ TEST 5 - HapticFeedback.mediumImpact() ERROR: $e');
  }

  // Test 6: Flutter's HapticFeedback.lightImpact
  try {
    await HapticFeedback.lightImpact();
    if (kDebugMode) print('üß™ TEST 6 - HapticFeedback.lightImpact(): SUCCESS');
    await Future.delayed(Duration(milliseconds: 200));
  } catch (e) {
    if (kDebugMode) print('üß™ TEST 6 - HapticFeedback.lightImpact() ERROR: $e');
  }

  // Test 7: Flutter's HapticFeedback.heavyImpact
  try {
    await HapticFeedback.heavyImpact();
    if (kDebugMode) print('üß™ TEST 7 - HapticFeedback.heavyImpact(): SUCCESS');
    await Future.delayed(Duration(milliseconds: 200));
  } catch (e) {
    if (kDebugMode) print('üß™ TEST 7 - HapticFeedback.heavyImpact() ERROR: $e');
  }

  // Test 8: Flutter's HapticFeedback.selectionClick
  try {
    await HapticFeedback.selectionClick();
    if (kDebugMode)
      print('üß™ TEST 8 - HapticFeedback.selectionClick(): SUCCESS');
    await Future.delayed(Duration(milliseconds: 200));
  } catch (e) {
    if (kDebugMode)
      print('üß™ TEST 8 - HapticFeedback.selectionClick() ERROR: $e');
  }

  // Test 9: Manual platform channel
  try {
    const platform = MethodChannel('flutter/haptic_feedback');
    await platform.invokeMethod('vibrate', {'duration': 50});
    if (kDebugMode) print('üß™ TEST 9 - Manual platform channel: SUCCESS');
  } catch (e) {
    if (kDebugMode) print('üß™ TEST 9 - Manual platform channel ERROR: $e');
  }

  if (kDebugMode) {
    print('üß™ HAPTIC TEST: Complete! Check above for working methods.');
    print('üí° If no tests show SUCCESS, the device may not support vibration.');
  }
}

void main() async {
  // Make main async
  WidgetsFlutterBinding.ensureInitialized();

  // Initialize Firebase
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );

  // Lock orientation to portrait only
  SystemChrome.setPreferredOrientations([
    DeviceOrientation.portraitUp,
    DeviceOrientation.portraitDown,
  ]);

  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: SplashScreen(),
      debugShowCheckedModeBanner: false,
    );
  }
}

class SplashScreen extends StatefulWidget {
  @override
  State<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends State<SplashScreen> {
  static const List<String> quotes = [
    //"ÊîπËÆä",
    "ÈùúÂæÖÈÄô‰∏ÄÁßí‰∏ñÁïåÊîπËÆäÔºåÊäëÊàñÊääÊè°ÈÄô‰∏ÄÁßíËµ∞ÈÅç‰∏ñÁïå",
  ];

  late String randomQuote;

  @override
  void initState() {
    super.initState();
    randomQuote = quotes[Random().nextInt(quotes.length)];
    Future.delayed(Duration(seconds: 5), () {
      Navigator.of(context).pushReplacement(
        MaterialPageRoute(builder: (_) => TimerList()),
      );

      // Check for app updates after navigating to main screen
      _checkForUpdates();
    });
  }

  void _checkForUpdates() async {
    // Wait a bit for the main screen to load
    await Future.delayed(Duration(seconds: 3));

    if (mounted) {
      try {
        // Check for updates silently (don't show "no update" dialog)
        AppUpdateManager.checkForUpdates(context, showNoUpdateDialog: false);
      } catch (e) {
        if (kDebugMode) {
          print('Update check failed: $e');
        }
        // Silently fail - don't interrupt user experience
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.white,
      body: SafeArea(
        child: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              Expanded(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  crossAxisAlignment: CrossAxisAlignment.center,
                  children: [
                    Image.asset('assets/rmac_timer.jpeg'),
                    SizedBox(height: 24),
                    Text(
                      'RMAC - MULTI TIMER',
                      style:
                          TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
                      textAlign: TextAlign.center,
                    ),
                    SizedBox(height: 24),
                    Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 32.0),
                      child: Text(
                        randomQuote,
                        style: TextStyle(
                            fontSize: 14, fontStyle: FontStyle.italic),
                        textAlign: TextAlign.center,
                      ),
                    ),
                    SizedBox(height: 32),
                    CircularProgressIndicator(),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class TimerList extends StatefulWidget {
  @override
  _TimerListState createState() => _TimerListState();
}

// Timer state class to persist timer data across widget rebuilds
class TimerState {
  final String id;
  Timer? periodicTimer;
  bool isRunning = false;
  Stopwatch lapStopwatch = Stopwatch();
  String currentLapTimeValue = '00:00:00';
  int currentLapNumber = 1;
  Stopwatch stopwatch = Stopwatch();
  String timerValue = '00:00:00';
  String previousTime = '00:00:00';
  List<LapEntry> lapEntries = [];
  int lapNumber = 0;

  // Firebase sync fields
  int elapsedMilliseconds = 0; // Total elapsed time
  DateTime? lastStartTime; // When the timer was last started
  DateTime? lastLapStartTime; // When the current lap was last started
  bool isSyncing = false; // Flag to prevent sync loops
  int stopwatchOffset = 0; // Offset to sync stopwatch with remote time
  int lapStopwatchOffset = 0; // Offset to sync lap stopwatch with remote time

  TimerState(this.id);

  void dispose() {
    if (kDebugMode) {
      print('‚ö†Ô∏è Disposing TimerState: $id');
    }
    periodicTimer?.cancel();
    periodicTimer = null;
    stopwatch.stop();
    lapStopwatch.stop();
  }

  // Convert to Firestore map
  Map<String, dynamic> toFirestore() {
    return {
      'isRunning': isRunning,
      'elapsedMilliseconds': elapsedMilliseconds,
      'lastStartTime': lastStartTime?.toIso8601String(),
      'lastLapStartTime': lastLapStartTime?.toIso8601String(),
      'timerValue': timerValue,
      'previousTime': previousTime,
      'lapNumber': lapNumber,
      'currentLapNumber': currentLapNumber,
      'lapElapsedMilliseconds':
          lapStopwatch.elapsedMilliseconds + lapStopwatchOffset,
      'lapEntries': lapEntries
          .map((e) => {
                'lapTime': e.lapTime,
                'splitTime': e.splitTime,
              })
          .toList(),
      'lastUpdated': FieldValue.serverTimestamp(),
      'lastActionUserId': '', // Will be set by _syncToFirebase
    };
  }

  // Update from Firestore data
  void updateFromFirestore(Map<String, dynamic> data) {
    if (isSyncing) return; // Prevent update loops

    isRunning = data['isRunning'] ?? false;
    elapsedMilliseconds = data['elapsedMilliseconds'] ?? 0;

    // Only update display values if timer is not running
    // For running timers, the periodic timer will handle display updates
    if (!isRunning) {
      timerValue = data['timerValue'] ?? '00:00:00';
      if (kDebugMode) {
        print('üìù Updated display value from Firebase: $timerValue (stopped)');
      }
    } else {
      if (kDebugMode) {
        print('‚è≠Ô∏è Skipped display value update (timer is running)');
      }
    }

    previousTime = data['previousTime'] ?? '00:00:00';
    lapNumber = data['lapNumber'] ?? 0;
    currentLapNumber = data['currentLapNumber'] ?? 1;

    if (data['lastStartTime'] != null) {
      lastStartTime = DateTime.parse(data['lastStartTime']);
    }

    if (data['lastLapStartTime'] != null) {
      lastLapStartTime = DateTime.parse(data['lastLapStartTime']);
    }

    // Update lap entries
    if (data['lapEntries'] != null) {
      lapEntries = (data['lapEntries'] as List)
          .map((e) => LapEntry(
                lapTime: e['lapTime'] ?? '00:00:00',
                splitTime: e['splitTime'] ?? '00:00:00',
              ))
          .toList();
    }

    // Restore lap stopwatch elapsed time using offset technique
    int remoteLapElapsed = data['lapElapsedMilliseconds'] ?? 0;
    // Update the offset so that lapStopwatch.elapsedMilliseconds + lapStopwatchOffset = remoteLapElapsed
    lapStopwatchOffset = remoteLapElapsed - lapStopwatch.elapsedMilliseconds;
  }
}

class _TimerListState extends State<TimerList>
    with TickerProviderStateMixin, WidgetsBindingObserver {
  final ScrollController _scrollController = ScrollController();
  List<String> runnerNames = ['Runner 1', 'Runner 2', 'Runner 3'];
  late List<GlobalKey<_TimerRowState>> rowKeys;

  // NEW: Persistent timer states that survive scrolling
  Map<String, TimerState> timerStates = {};

  // Multi-user session management
  String _currentUserId = '';
  String? _sessionOwnerId; // Track who created/owns the session
  bool _isHost =
      true; // Track if current user is the host (true = in own session, false = joined someone else's)
  Map<String, dynamic> _connectedUsers = {}; // userId -> {lastSeen, color}
  bool _isOnlineMode = false;
  String? _lastActionUserId; // Track who did the last action
  String? _lastActionType; // Track what type of action (start/stop/reset)
  String? _lastActionTimerId; // Track which timer was affected
  Timer? _actionIndicatorTimer;
  StreamSubscription? _usersListener;
  StreamSubscription? _timersListener;
  Timer? _heartbeatTimer;
  bool _userWasRemoved = false;
  bool _isUserListVisible = false; // Track if user list panel is shown
  bool _isVoluntaryJoin = false; // Track if user is voluntarily joining
  bool _isInActiveSession =
      false; // Track if user is in an actively joined session (not their own)
  bool _justCompletedInitialSync =
      false; // Track if we just completed initial sync

  // Backup for restoring when leaving session
  List<String>? _backupRunnerNames;
  Map<String, TimerState>? _backupTimerStates;
  String? _backupSessionId;

  int? pendingDeleteIndex;

  // Sliding page functionality
  late AnimationController _slideController;
  late Animation<double> _slideAnimation;
  bool _isSlidePageVisible = false;

  // LAP drawer functionality
  late AnimationController _lapSlideController;
  late Animation<double> _lapSlideAnimation;
  bool _isLapSlidePageVisible = false;

  // Pace calculation variables
  double _paceValue = 5.0; // Pace in minutes (e.g., 5.5 = 5:30)
  bool _isEditingPace = false;
  late TextEditingController _paceController;
  late FocusNode _paceFocusNode;

  // Controllers and state for editable distance times
  Map<String, TextEditingController> _distanceControllers = {};
  String? _editingDistance;
  DateTime? _lastDragTime;
  DateTime? _lastHapticTime;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this); // Add lifecycle observer

    rowKeys = List.generate(
      runnerNames.length,
      (_) => GlobalKey<_TimerRowState>(),
    );
    // Initialize timer states for each runner
    _initializeTimerStates();
    loadRunnerNames();

    // Initialize user session first (async), then check if we should rejoin
    _initializeUserSession().then((_) async {
      final prefs = await SharedPreferences.getInstance();
      bool wasInActiveSession = prefs.getBool('was_in_active_session') ?? false;

      if (wasInActiveSession) {
        // User was in an active joined session when app was killed - rejoin it
        if (kDebugMode) {
          print('üîÑ Rejoining active session: $TIMER_SESSION_ID');
        }
        _isInActiveSession = true;

        // ‚ö†Ô∏è IMPORTANT: Backup current configuration before rejoining
        // This ensures we can restore the original state if user quits later
        _backupCurrentConfiguration();

        // Sync with Firebase and start listeners to rejoin the session
        await _performInitialSync();
        _initializeFirebaseListeners();
      } else {
        // Even if not explicitly rejoining, always sync and listen to Firebase
        // This handles hot restart scenarios where the app is already in a session
        await _performInitialSync();
        _initializeFirebaseListeners();
      }

      // Always start these
      _startPresenceHeartbeat();
      _listenToConnectedUsers();
    });

    // Initialize pace editing controllers
    _paceController =
        TextEditingController(text: _formatPaceDisplay(_paceValue));
    _paceFocusNode = FocusNode();
    _paceFocusNode.addListener(() {
      if (!_paceFocusNode.hasFocus && _isEditingPace) {
        _finishEditingPace();
      }
    });

    // Initialize distance time controllers
    final distances = [
      '400m',
      '550m',
      '800m',
      '1200m',
      '1400m',
      '1600m',
      '3km',
      '5km',
      '10km',
      'Half',
      'Full'
    ];
    for (String distance in distances) {
      _distanceControllers[distance] = TextEditingController();
    }

    // Initialize slide animation
    _slideController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    _slideAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _slideController,
      curve: Curves.easeInOut,
    ));

    // Initialize LAP slide animation
    _lapSlideController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    _lapSlideAnimation = Tween<double>(
      begin: 0.0,
      end: 1.0,
    ).animate(CurvedAnimation(
      parent: _lapSlideController,
      curve: Curves.easeInOut,
    ));
  }

  // Initialize user session and load/generate session ID
  Future<void> _initializeUserSession() async {
    try {
      final prefs = await SharedPreferences.getInstance();

      // Get or create user ID
      _currentUserId = prefs.getString('user_id') ?? '';
      if (_currentUserId.isEmpty) {
        _currentUserId = await _generateUserId();
        await prefs.setString('user_id', _currentUserId);
      }

      // Check if we have a session ID from shared link (stored in prefs)
      String? savedSessionId = prefs.getString('shared_session_id');
      if (savedSessionId != null && savedSessionId.isNotEmpty) {
        TIMER_SESSION_ID = savedSessionId;
      } else {
        // Generate new session ID for first time users
        TIMER_SESSION_ID = _generateSessionId();
        await prefs.setString('shared_session_id', TIMER_SESSION_ID);
      }

      if (kDebugMode) {
        print('üë§ User ID: $_currentUserId');
        print('üîó Session ID: $TIMER_SESSION_ID');
      }

      // Register this user in the session
      await _updateUserPresence();

      if (kDebugMode) {
        print('‚úÖ User session initialized and presence registered');
      }

      // Listen to other users in the session
      _listenToConnectedUsers();

      // Fetch current users immediately to populate UI
      await _fetchConnectedUsers();
    } catch (e) {
      if (kDebugMode) {
        print('‚ùå Error initializing user session: $e');
      }
    }
  }

  Future<String> _generateUserId() async {
    try {
      final deviceInfo = DeviceInfoPlugin();
      String deviceId = '';

      if (Platform.isAndroid) {
        final androidInfo = await deviceInfo.androidInfo;
        deviceId = androidInfo.id;
      } else if (Platform.isIOS) {
        final iosInfo = await deviceInfo.iosInfo;
        deviceId = iosInfo.identifierForVendor ?? '';
      }

      if (deviceId.isNotEmpty) {
        return 'user_${deviceId.substring(0, min(8, deviceId.length))}';
      }
    } catch (e) {
      if (kDebugMode) print('Error getting device ID: $e');
    }

    // Fallback: generate random ID
    return 'user_${Random().nextInt(999999).toString().padLeft(6, '0')}';
  }

  String _generateSessionId() {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    final random = Random();
    return List.generate(6, (index) => chars[random.nextInt(chars.length)])
        .join();
  }

  Future<void> _updateUserPresence() async {
    try {
      final firestore = FirebaseFirestore.instance;

      // Check if we need to set the session owner
      final sessionDoc = await firestore
          .collection('timer_sessions')
          .doc(TIMER_SESSION_ID)
          .get();

      String? existingOwnerId = sessionDoc.data()?['ownerId'];
      bool shouldSetOwner = false;

      // Set owner if:
      // 1. Session doc doesn't exist OR has no owner
      // 2. AND we are the host (not a guest joining someone's session)
      // OR if owner is null and we're the only one here, claim it
      if (!sessionDoc.exists || existingOwnerId == null) {
        // Check if there are other users in the session
        final usersSnapshot = await firestore
            .collection('timer_sessions')
            .doc(TIMER_SESSION_ID)
            .collection('users')
            .get();

        // If we're host OR if we're the only one/first one, set as owner
        if (_isHost || usersSnapshot.docs.isEmpty) {
          shouldSetOwner = true;
        }
      }

      // Update user presence
      await firestore
          .collection('timer_sessions')
          .doc(TIMER_SESSION_ID)
          .collection('users')
          .doc(_currentUserId)
          .set({
        'lastSeen': FieldValue.serverTimestamp(),
        'color': _getUserColor(_currentUserId),
      }, SetOptions(merge: true));

      // Set session owner if needed
      if (shouldSetOwner) {
        await firestore.collection('timer_sessions').doc(TIMER_SESSION_ID).set({
          'ownerId': _currentUserId,
        }, SetOptions(merge: true));
        _sessionOwnerId = _currentUserId;

        if (kDebugMode) {
          print('üëë Set session owner: $_currentUserId');
        }
      } else {
        // Load session owner (use existing or the one we just read)
        _sessionOwnerId = existingOwnerId ?? sessionDoc.data()?['ownerId'];

        // If owner is null but we're a guest joining, find the first user and treat them as owner
        if (_sessionOwnerId == null && !_isHost) {
          final usersSnapshot = await firestore
              .collection('timer_sessions')
              .doc(TIMER_SESSION_ID)
              .collection('users')
              .get();

          // Find the first user that's not us
          for (var doc in usersSnapshot.docs) {
            if (doc.id != _currentUserId) {
              _sessionOwnerId = doc.id;
              if (kDebugMode) {
                print(
                    'üëë Inferred session owner (first user found): $_sessionOwnerId');
              }
              break;
            }
          }
        }

        if (kDebugMode) {
          print(
              'üëë Session owner: $_sessionOwnerId (I am ${_isHost ? "HOST" : "GUEST"})');
        }
      }
    } catch (e) {
      if (kDebugMode) print('Error updating presence: $e');
    }
  }

  Future<void> _removeUserPresence({bool isVoluntaryQuit = false}) async {
    try {
      final firestore = FirebaseFirestore.instance;

      // If voluntary quit, set a flag before deleting
      if (isVoluntaryQuit) {
        await firestore
            .collection('timer_sessions')
            .doc(TIMER_SESSION_ID)
            .collection('users')
            .doc(_currentUserId)
            .set({
          'voluntaryQuit': true,
          'lastSeen': FieldValue.serverTimestamp(),
        }, SetOptions(merge: true));

        // Wait a moment to ensure other clients see the flag
        await Future.delayed(Duration(milliseconds: 100));
      }

      // Delete user presence
      await firestore
          .collection('timer_sessions')
          .doc(TIMER_SESSION_ID)
          .collection('users')
          .doc(_currentUserId)
          .delete();

      if (kDebugMode) {
        print(
            'üö™ Removed user presence for $_currentUserId (voluntary: $isVoluntaryQuit)');
      }
    } catch (e) {
      if (kDebugMode) print('Error removing presence: $e');
    }
  }

  void _startPresenceHeartbeat() {
    _heartbeatTimer?.cancel();
    // Update presence every 30 seconds
    _heartbeatTimer = Timer.periodic(Duration(seconds: 30), (timer) {
      if (mounted && !_userWasRemoved) {
        _updateUserPresence();
      } else {
        timer.cancel();
      }
    });
  }

  Future<void> _fetchConnectedUsers() async {
    try {
      if (kDebugMode) {
        print(
            'üîç Starting fetch for session: $TIMER_SESSION_ID, currentUser: $_currentUserId');
      }

      final firestore = FirebaseFirestore.instance;
      final snapshot = await firestore
          .collection('timer_sessions')
          .doc(TIMER_SESSION_ID)
          .collection('users')
          .get();

      if (kDebugMode) {
        print('üîç Fetched ${snapshot.docs.length} total documents');
        for (var doc in snapshot.docs) {
          print('  - User: ${doc.id}');
        }
      }

      if (!mounted) return;

      setState(() {
        _connectedUsers.clear();
        for (var doc in snapshot.docs) {
          if (doc.id != _currentUserId) {
            _connectedUsers[doc.id] = doc.data();
          }
        }

        // Update online/offline mode
        bool wasOnline = _isOnlineMode;
        _isOnlineMode = _connectedUsers.length > 0;

        if (kDebugMode) {
          print(
              'üîç Fetched users: ${_connectedUsers.length + 1} total (Mode: ${_isOnlineMode ? "ONLINE" : "OFFLINE"})');
          print('üìã User IDs: ${_connectedUsers.keys.toList()}');
          if (wasOnline != _isOnlineMode) {
            print('üîÑ Mode changed: $wasOnline ‚Üí $_isOnlineMode');
          }
        }
      });
    } catch (e) {
      if (kDebugMode) {
        print('‚ùå Error fetching connected users: $e');
      }
    }
  }

  Future<void> _handleUserRemoval({bool shouldRestoreBackup = true}) async {
    if (kDebugMode) {
      print(
          'üö® _handleUserRemoval called with shouldRestoreBackup: $shouldRestoreBackup');
      print('  Current timers: ${runnerNames.length}');
      print('  Backup available: ${_backupRunnerNames != null}');
      if (_backupRunnerNames != null) {
        print('  Backup timers: ${_backupRunnerNames!.length}');
      }
    }

    // Generate a new session code for this user
    String newSessionCode = _generateSessionId();
    TIMER_SESSION_ID = newSessionCode;

    // Save the new session code
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('session_id', newSessionCode);

    if (kDebugMode) {
      print('üÜï Generated new session code: $newSessionCode');
    }

    // Conditionally restore backup configuration
    if (shouldRestoreBackup) {
      if (kDebugMode) {
        print('üîÑ Restoring backup configuration');
      }
      _restoreBackupConfiguration();
      if (kDebugMode) {
        print('‚úÖ After restore: ${runnerNames.length} timers');
      }
    } else {
      if (kDebugMode) {
        print('üìå Keeping current timers (no backup restore)');
      }
      // Keep current timers, just save them
      await saveRunnerNames();
    }

    // Clear all backups
    _backupSessionId = null;
    _backupRunnerNames = null;
    _backupTimerStates = null;

    // Re-register user presence in the new session as host
    _isHost = true;
    await _updateUserPresence();

    // Reset the flag and restart listeners for the new session
    _userWasRemoved = false;
    _startPresenceHeartbeat();
    _listenToConnectedUsers();
    await _performInitialSync();
    _initializeFirebaseListeners();

    if (mounted) {
      String message = shouldRestoreBackup
          ? 'You were removed from the session. Timers restored.'
          : 'Host ended the session. You now have your own session.';
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(message),
          backgroundColor: Colors.orange,
          duration: Duration(seconds: 5),
        ),
      );
    }
  }

  void _listenToConnectedUsers() {
    _usersListener?.cancel();
    final firestore = FirebaseFirestore.instance;
    _usersListener = firestore
        .collection('timer_sessions')
        .doc(TIMER_SESSION_ID)
        .collection('users')
        .snapshots()
        .listen((snapshot) async {
      if (!mounted) return;

      // Check if session owner voluntarily quit
      for (var change in snapshot.docChanges) {
        if (change.type == DocumentChangeType.removed) {
          String removedUserId = change.doc.id;

          // Check if this was the session owner
          if (_sessionOwnerId != null && removedUserId == _sessionOwnerId) {
            // Check if it was a voluntary quit by looking at the previous data
            var previousData = change.doc.data();
            bool wasVoluntaryQuit = previousData?['voluntaryQuit'] == true;

            if (kDebugMode) {
              print(
                  'üëë Session owner removed: $removedUserId (voluntary: $wasVoluntaryQuit)');
            }

            // If owner voluntarily quit, kick all other users
            if (wasVoluntaryQuit && removedUserId != _currentUserId) {
              if (kDebugMode) {
                print('üö´ Session owner quit voluntarily - kicking all users');
                print('   Current user will be kicked and backup restored');
              }

              // Trigger removal handling for current user
              // Restore backup - guests get their original timers back
              _userWasRemoved = true;
              _heartbeatTimer?.cancel();
              await _handleUserRemoval(shouldRestoreBackup: true);
              return; // Exit early
            }
          }

          if (kDebugMode) {
            print('üëã User removed: $removedUserId');
          }
        }
      }

      // Check if current user still exists in the session
      bool currentUserExists = false;
      for (var doc in snapshot.docs) {
        if (doc.id == _currentUserId) {
          currentUserExists = true;
          break;
        }
      }

      // If current user was removed by another user (not voluntary join)
      if (!currentUserExists && !_userWasRemoved && !_isVoluntaryJoin) {
        _userWasRemoved = true;
        _heartbeatTimer?.cancel();

        if (kDebugMode) {
          print('üö´ You were removed from the session');
        }

        // Handle removal in a separate async method
        _handleUserRemoval();
      }

      setState(() {
        Map<String, dynamic> oldUsers = Map.from(_connectedUsers);
        _connectedUsers.clear();

        for (var doc in snapshot.docs) {
          if (doc.id != _currentUserId) {
            _connectedUsers[doc.id] = doc.data();
          }
        }

        // Update online/offline mode
        _isOnlineMode = _connectedUsers.length > 0;

        // Log changes
        if (kDebugMode) {
          if (oldUsers.length != _connectedUsers.length) {
            print(
                'üë• User count changed: ${oldUsers.length} ‚Üí ${_connectedUsers.length}');
          }
          print(
              'üë• Connected users: ${_connectedUsers.length + 1} (Mode: ${_isOnlineMode ? "ONLINE" : "OFFLINE"})');
          print('üë• Current user IDs: ${_connectedUsers.keys.toList()}');
        }
      });

      if (kDebugMode) {
        print('üîÑ setState completed in listener');
      }
    });
  }

  int _getUserColor(String userId) {
    // Generate consistent color for user based on their ID
    int hash = userId.hashCode;
    return 0xFF000000 | (hash & 0x00FFFFFF);
  }

  void _showRemoteActionIndicator(String userId,
      {String? action, String? timerId}) {
    if (kDebugMode) {
      print('üîî _showRemoteActionIndicator called:');
      print('   userId: $userId');
      print('   action: $action');
      print('   timerId: $timerId');
      print('   _isOnlineMode: $_isOnlineMode');
      print('   mounted: $mounted');
    }

    if (!_isOnlineMode) {
      if (kDebugMode) {
        print('‚ö†Ô∏è Skipping indicator - not in online mode');
      }
      return;
    }

    setState(() {
      _lastActionUserId = userId;
      _lastActionType = action;
      _lastActionTimerId = timerId;
    });

    if (kDebugMode) {
      print(
          '‚úÖ Indicator state set: _lastActionUserId=$_lastActionUserId, _lastActionType=$_lastActionType, _lastActionTimerId=$_lastActionTimerId');
    }

    _actionIndicatorTimer?.cancel();
    _actionIndicatorTimer = Timer(Duration(milliseconds: 1500), () {
      if (mounted) {
        setState(() {
          _lastActionUserId = null;
          _lastActionType = null;
          _lastActionTimerId = null;
        });
      }
    });
  }

  Future<void> _shareSessionLink() async {
    // Save current timer configuration to Firebase for others to load
    await _saveSessionConfiguration();

    await Clipboard.setData(ClipboardData(text: TIMER_SESSION_ID));

    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                'Session code copied: $TIMER_SESSION_ID',
                style: TextStyle(fontWeight: FontWeight.bold),
              ),
              SizedBox(height: 4),
              Text(
                'Share this code. Others can join by clicking the Join button.',
                style: TextStyle(fontSize: 12),
              ),
            ],
          ),
          duration: Duration(seconds: 5),
          action: SnackBarAction(
            label: 'Share',
            onPressed: () {
              Share.share(
                  'Join my timer session! Open the app and use Join button with code: $TIMER_SESSION_ID');
            },
          ),
        ),
      );
    }
  }

  Future<void> _saveSessionConfiguration() async {
    try {
      // Convert timerStates to a serializable format
      Map<String, Map<String, dynamic>> serializedStates = {};
      timerStates.forEach((key, state) {
        serializedStates[key] = {
          'isRunning': state.isRunning,
          'elapsedMilliseconds': state.elapsedMilliseconds,
          'lapEntries': state.lapEntries
              .map((lap) => {
                    'lapTime': lap.lapTime,
                    'splitTime': lap.splitTime,
                  })
              .toList(),
        };
      });

      await FirebaseFirestore.instance
          .collection('timer_sessions')
          .doc(TIMER_SESSION_ID)
          .set({
        'runnerNames': runnerNames,
        'timerStates': serializedStates,
        'lastUpdated': FieldValue.serverTimestamp(),
      });

      if (kDebugMode) {
        print('üíæ Session configuration saved: ${runnerNames.length} timers');
      }
    } catch (e) {
      if (kDebugMode) {
        print('‚ùå Error saving session configuration: $e');
      }
    }
  }

  Future<void> _loadSessionConfiguration() async {
    try {
      final doc = await FirebaseFirestore.instance
          .collection('timer_sessions')
          .doc(TIMER_SESSION_ID)
          .get();

      if (doc.exists && doc.data() != null) {
        final data = doc.data()!;

        if (data['runnerNames'] != null) {
          setState(() {
            runnerNames = List<String>.from(data['runnerNames']);
            rowKeys = List.generate(
                runnerNames.length, (index) => GlobalKey<_TimerRowState>());

            // Load timer states
            if (data['timerStates'] != null) {
              timerStates.clear();
              Map<String, dynamic> savedStates =
                  Map<String, dynamic>.from(data['timerStates']);
              savedStates.forEach((key, value) {
                TimerState state = TimerState(key);
                state.isRunning = value['isRunning'] ?? false;
                state.elapsedMilliseconds = value['elapsedMilliseconds'] ?? 0;

                // Update the display value from elapsed time
                state.timerValue = _formatTime(state.elapsedMilliseconds);
                state.stopwatchOffset = state.elapsedMilliseconds;

                if (value['lapEntries'] != null) {
                  state.lapEntries = (value['lapEntries'] as List)
                      .map((lap) => LapEntry(
                            lapTime: lap['lapTime'],
                            splitTime: lap['splitTime'],
                          ))
                      .toList();
                }
                timerStates[key] = state;
              });
            }
          });

          if (kDebugMode) {
            print(
                'üì• Session configuration loaded: ${runnerNames.length} timers');
          }
        }
      }
    } catch (e) {
      if (kDebugMode) {
        print('‚ùå Error loading session configuration: $e');
      }
    }
  }

  void _backupCurrentConfiguration() {
    _backupSessionId = TIMER_SESSION_ID;
    _backupRunnerNames = List<String>.from(runnerNames);
    _backupTimerStates = {};
    timerStates.forEach((key, state) {
      TimerState backup = TimerState(key);
      backup.isRunning = state.isRunning;
      backup.elapsedMilliseconds = state.elapsedMilliseconds;
      backup.timerValue = state.timerValue;
      backup.previousTime = state.previousTime;
      backup.currentLapNumber = state.currentLapNumber;
      backup.lapNumber = state.lapNumber;
      backup.currentLapTimeValue = state.currentLapTimeValue;
      backup.stopwatchOffset = state.stopwatchOffset;
      backup.lapStopwatchOffset = state.lapStopwatchOffset;
      backup.lapEntries = state.lapEntries
          .map((lap) => LapEntry(
                lapTime: lap.lapTime,
                splitTime: lap.splitTime,
              ))
          .toList();
      _backupTimerStates![key] = backup;
    });

    if (kDebugMode) {
      print(
          'üíæ Backed up current configuration: ${runnerNames.length} timers, session: $_backupSessionId');
      print('üíæ Backup timer names: ${_backupRunnerNames?.join(", ")}');
      print('üíæ Backup state count: ${_backupTimerStates?.length}');
    }
  }

  void _restoreBackupConfiguration() {
    if (kDebugMode) {
      print('üîç Attempting to restore backup...');
      print('  _backupRunnerNames: $_backupRunnerNames');
      print('  _backupTimerStates: ${_backupTimerStates?.length} states');
      print('  _backupSessionId: $_backupSessionId');
    }

    if (_backupRunnerNames != null && _backupTimerStates != null) {
      setState(() {
        runnerNames = List<String>.from(_backupRunnerNames!);
        rowKeys = List.generate(
            runnerNames.length, (index) => GlobalKey<_TimerRowState>());

        // Clear existing timer states and stop any running timers
        timerStates.forEach((key, state) {
          state.dispose();
        });
        timerStates.clear();

        // Restore from backup with CORRECT timer IDs based on runner names
        // This ensures IDs match the format expected by Firebase sync
        for (int i = 0; i < runnerNames.length; i++) {
          String correctId = 'timer_${i}_${runnerNames[i]}';

          // Find matching backup state by runner name
          TimerState? backupState;
          for (var entry in _backupTimerStates!.entries) {
            if (entry.key.endsWith('_${runnerNames[i]}')) {
              backupState = entry.value;
              break;
            }
          }

          if (backupState != null) {
            // Create restored state with correct ID
            TimerState restored = TimerState(correctId);
            restored.isRunning = backupState.isRunning;
            restored.elapsedMilliseconds = backupState.elapsedMilliseconds;
            restored.timerValue = backupState.timerValue;
            restored.previousTime = backupState.previousTime;
            restored.currentLapNumber = backupState.currentLapNumber;
            restored.lapNumber = backupState.lapNumber;
            restored.currentLapTimeValue = backupState.currentLapTimeValue;
            restored.stopwatchOffset = backupState.stopwatchOffset;
            restored.lapStopwatchOffset = backupState.lapStopwatchOffset;

            // Update the display value from elapsed time if needed
            if (restored.timerValue == '00:00:00' &&
                restored.elapsedMilliseconds > 0) {
              restored.timerValue = _formatTime(restored.elapsedMilliseconds);
            }

            restored.lapEntries = backupState.lapEntries
                .map((lap) => LapEntry(
                      lapTime: lap.lapTime,
                      splitTime: lap.splitTime,
                    ))
                .toList();
            timerStates[correctId] = restored;
          } else {
            // No backup found for this runner, create empty state
            timerStates[correctId] = TimerState(correctId);
          }
        }
      });

      if (kDebugMode) {
        print('üì• Restored backup configuration: ${runnerNames.length} timers');
        print('  Timer states restored: ${timerStates.keys.toList()}');
      }

      // Don't clear backups here - let calling methods handle it
    } else {
      if (kDebugMode) {
        print('‚ö†Ô∏è Cannot restore backup - backup data is null');
      }
    }
  }

  Future<void> _leaveSession() async {
    try {
      // Mark as voluntary join to prevent removal message
      _isVoluntaryJoin = true;
      _isInActiveSession = false; // No longer in active session

      if (_isHost) {
        // HOST QUIT: Kick all guests, keep own timers (no restoration needed)
        if (kDebugMode) {
          print('üëë Host is quitting - kicking all guests');
        }

        // Set voluntary quit flag to kick all guests
        await _removeUserPresence(isVoluntaryQuit: true);
        _usersListener?.cancel();
        _timersListener?.cancel();
        _heartbeatTimer?.cancel();
        _userWasRemoved = false;

        // Generate new session ID for host
        TIMER_SESSION_ID = _generateSessionId();

        // Save to preferences
        final prefs = await SharedPreferences.getInstance();
        await prefs.setString('shared_session_id', TIMER_SESSION_ID);
        await prefs.setBool('was_in_active_session', false);

        // Host keeps their timers - NO restoration needed
        // Clear any backup data
        _backupSessionId = null;
        _backupRunnerNames = null;
        _backupTimerStates = null;

        // Re-register in new session as host
        _isHost = true;
        await _updateUserPresence();
        _startPresenceHeartbeat();
        _listenToConnectedUsers();

        // Sync current timers to new session
        await _performInitialSync();
        _initializeFirebaseListeners();

        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Session ended. All guests removed.'),
              backgroundColor: Colors.orange,
              duration: Duration(seconds: 3),
            ),
          );
        }
      } else {
        // GUEST QUIT: Leave session and restore backup timers
        if (kDebugMode) {
          print('üë§ Guest is quitting - restoring backup timers');
        }

        // Backup current configuration BEFORE leaving if not already backed up
        if (_backupSessionId == null) {
          _backupCurrentConfiguration();
        }

        // Remove from current session without kicking others
        await _removeUserPresence(isVoluntaryQuit: false);
        _usersListener?.cancel();
        _timersListener?.cancel();
        _heartbeatTimer?.cancel();
        _userWasRemoved = false;

        // Generate a completely new session ID
        TIMER_SESSION_ID = _generateSessionId();

        // Save to preferences and clear active session flag
        final prefs = await SharedPreferences.getInstance();
        await prefs.setString('shared_session_id', TIMER_SESSION_ID);
        await prefs.setBool('was_in_active_session', false);

        if (kDebugMode) {
          print('üëã Left session, new session: $TIMER_SESSION_ID');
        }

        // Restore backup configuration
        _restoreBackupConfiguration();

        // Save restored runner names to SharedPreferences immediately
        await saveRunnerNames();

        // Clear all backups AFTER successful restore
        _backupSessionId = null;
        _backupRunnerNames = null;
        _backupTimerStates = null;

        // Re-register in own session as host
        _isHost = true;
        await _updateUserPresence();
        _startPresenceHeartbeat();
        _listenToConnectedUsers();

        // Start with initial sync - sync restored timers to Firebase
        await _performInitialSync();
        _initializeFirebaseListeners();

        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Left session. Your timers restored.'),
              backgroundColor: Colors.green,
              duration: Duration(seconds: 3),
            ),
          );
        }
      }

      _isVoluntaryJoin = false;
    } catch (e) {
      if (kDebugMode) {
        print('‚ùå Error leaving session: $e');
      }
    }
  }

  Future<void> _removeUser(String userId) async {
    try {
      await FirebaseFirestore.instance
          .collection('timer_sessions')
          .doc(TIMER_SESSION_ID)
          .collection('users')
          .doc(userId)
          .delete();

      if (kDebugMode) {
        print('üóëÔ∏è Removed user: $userId');
      }
    } catch (e) {
      if (kDebugMode) {
        print('Error removing user: $e');
      }
    }
  }

  Future<void> _showJoinSessionDialog() async {
    final TextEditingController sessionCodeController = TextEditingController();

    return showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: Row(
            children: [
              Icon(Icons.login, color: Colors.blue),
              SizedBox(width: 8),
              Text('Join Session'),
            ],
          ),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                'Enter the 6-character session code shared by another user:',
                style: TextStyle(fontSize: 14),
              ),
              SizedBox(height: 16),
              TextField(
                controller: sessionCodeController,
                decoration: InputDecoration(
                  labelText: 'Session Code',
                  hintText: 'e.g., ABC123',
                  border: OutlineInputBorder(),
                  prefixIcon: Icon(Icons.vpn_key),
                ),
                textCapitalization: TextCapitalization.characters,
                maxLength: 6,
                autofocus: true,
                onSubmitted: (value) {
                  if (value.length == 6) {
                    Navigator.of(context).pop();
                    _joinSession(value.toUpperCase());
                  }
                },
              ),
              SizedBox(height: 8),
              Text(
                'Current session: $TIMER_SESSION_ID',
                style: TextStyle(fontSize: 12, color: Colors.grey[600]),
              ),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: Text('Cancel'),
            ),
            ElevatedButton(
              onPressed: () {
                final code = sessionCodeController.text.trim().toUpperCase();
                if (code.length == 6) {
                  Navigator.of(context).pop();
                  _joinSession(code);
                } else {
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(
                      content: Text('Please enter a valid 6-character code'),
                      backgroundColor: Colors.red,
                    ),
                  );
                }
              },
              child: Text('Join'),
            ),
          ],
        );
      },
    );
  }

  Future<void> _joinSession(String sessionCode) async {
    try {
      if (sessionCode == TIMER_SESSION_ID && !_userWasRemoved) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('You are already in this session'),
            backgroundColor: Colors.orange,
          ),
        );
        return;
      }

      // Mark as voluntary join to prevent removal message
      _isVoluntaryJoin = true;
      _isInActiveSession = true; // Mark as actively in a joined session
      _isHost = false; // Joining someone else's session makes us a guest

      // Backup current configuration before joining
      _backupCurrentConfiguration();

      // Remove from current session
      await _removeUserPresence();
      _usersListener?.cancel();
      _timersListener?.cancel();
      _heartbeatTimer?.cancel();
      _userWasRemoved = false;

      if (kDebugMode) {
        print('üîÑ Switching from session $TIMER_SESSION_ID to $sessionCode');
        print('üë§ Current user ID: $_currentUserId');
      }

      // Update session ID
      TIMER_SESSION_ID = sessionCode;

      // Save to preferences and mark as active session
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString('shared_session_id', TIMER_SESSION_ID);
      await prefs.setBool('was_in_active_session', true);

      if (kDebugMode) {
        print('üîó Joined session: $TIMER_SESSION_ID');
      }

      // Reconnect to new session
      await _updateUserPresence();

      if (kDebugMode) {
        print('‚úÖ Presence updated in new session');
      }

      _listenToConnectedUsers();

      if (kDebugMode) {
        print('‚úÖ User listener started');
      }

      // Manually fetch existing users in the session to populate UI immediately
      await _fetchConnectedUsers();

      // Perform initial sync before starting real-time listeners
      await _performInitialSync();

      _initializeFirebaseListeners();

      if (kDebugMode) {
        print('‚úÖ Timer listener started');
      }

      _startPresenceHeartbeat();

      if (kDebugMode) {
        print('‚úÖ Heartbeat started');
      }

      // Note: _loadSessionConfiguration() is NOT needed here because
      // _performInitialSync() already loads all timer states from Firebase
      // Loading again would overwrite the running timers with old saved state

      // Wait a moment for Firebase to sync, then refresh UI multiple times
      await Future.delayed(Duration(milliseconds: 500));
      if (mounted) {
        await _fetchConnectedUsers();
      }

      await Future.delayed(Duration(milliseconds: 500));
      if (mounted) {
        setState(() {
          if (kDebugMode) {
            print(
                'üîÑ UI refreshed - connected users: ${_connectedUsers.length}, online mode: $_isOnlineMode');
          }
        });
      }

      // One more refresh after another delay to catch late updates
      await Future.delayed(Duration(milliseconds: 500));
      if (mounted) {
        await _fetchConnectedUsers();
      }

      if (mounted) {
        _isVoluntaryJoin = false; // Reset flag
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Successfully joined session: $sessionCode'),
            backgroundColor: Colors.green,
            duration: Duration(seconds: 3),
          ),
        );
      }
    } catch (e) {
      if (kDebugMode) {
        print('‚ùå Error joining session: $e');
      }

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Failed to join session: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  void _initializeTimerStates() {
    for (int i = 0; i < runnerNames.length; i++) {
      String uniqueId = 'timer_${i}_${runnerNames[i]}';
      if (!timerStates.containsKey(uniqueId)) {
        timerStates[uniqueId] = TimerState(uniqueId);
      }
    }
  }

  // Perform initial sync with Firebase when joining a session
  Future<void> _performInitialSync() async {
    try {
      final firestore = FirebaseFirestore.instance;

      // Check if session has been initialized by checking session metadata
      final sessionDoc = await firestore
          .collection('timer_sessions')
          .doc(TIMER_SESSION_ID)
          .get();

      final snapshot = await firestore
          .collection('timer_sessions')
          .doc(TIMER_SESSION_ID)
          .collection('timers')
          .get();

      if (kDebugMode) {
        print(
            'üîÑ Initial sync: Found ${snapshot.docs.length} timers in Firebase');
        print('üìã Session initialized: ${sessionDoc.exists}');
      }

      // Determine if we should load from Firebase or sync local data
      bool shouldLoadFromFirebase = snapshot.docs.isNotEmpty;

      // Also check if session metadata exists (indicates session was previously initialized)
      if (sessionDoc.exists && sessionDoc.data()?['initialized'] == true) {
        shouldLoadFromFirebase = true;
      }

      if (!shouldLoadFromFirebase && snapshot.docs.isEmpty) {
        // No existing timers in Firebase and session not initialized
        // Wait briefly to avoid race condition with another user initializing
        await Future.delayed(Duration(milliseconds: 300));

        // Recheck if session was initialized by another user during the delay
        final recheckSession = await firestore
            .collection('timer_sessions')
            .doc(TIMER_SESSION_ID)
            .get();
        final recheckTimers = await firestore
            .collection('timer_sessions')
            .doc(TIMER_SESSION_ID)
            .collection('timers')
            .get();

        if (recheckTimers.docs.isNotEmpty ||
            (recheckSession.exists &&
                recheckSession.data()?['initialized'] == true)) {
          // Another user initialized during our delay - load from Firebase instead
          if (kDebugMode) {
            print('üì• Another user initialized session - loading their data');
          }
          // Recursively call to load from Firebase
          return await _performInitialSync();
        }

        // Still empty - we initialize the session
        if (kDebugMode) {
          print(
              'üì§ Initializing fresh session - syncing local timers to Firebase');
        }

        // Mark session as initialized with timestamp
        await firestore.collection('timer_sessions').doc(TIMER_SESSION_ID).set({
          'initialized': true,
          'initializedBy': _currentUserId,
          'initializedAt': FieldValue.serverTimestamp(),
        }, SetOptions(merge: true));

        // Sync local timers to Firebase
        for (var timerState in timerStates.values) {
          await _syncToFirebase(timerState);
        }
      } else {
        // Load existing timers from Firebase
        if (kDebugMode) {
          print(
              'üì• Loading existing timers from Firebase (${snapshot.docs.length} timers)');
        }

        // Create a set of Firebase timer IDs for cleanup
        Set<String> firebaseTimerIds =
            snapshot.docs.map((doc) => doc.id).toSet();

        // Remove local timer states that don't exist in Firebase
        List<String> localTimerIds = timerStates.keys.toList();
        for (String localId in localTimerIds) {
          if (!firebaseTimerIds.contains(localId)) {
            if (kDebugMode) {
              print('  Removing local timer $localId (not in Firebase)');
            }
            timerStates[localId]?.dispose();
            timerStates.remove(localId);
          }
        }

        for (var doc in snapshot.docs) {
          final data = doc.data();
          final timerId = doc.id;

          if (kDebugMode) {
            print('  Loading timer: $timerId');
          }

          // Find or create local timer state
          TimerState? timerState = timerStates[timerId];
          if (timerState == null) {
            // Timer exists in Firebase but not locally - create it
            timerState = TimerState(timerId);
            timerStates[timerId] = timerState;
            if (kDebugMode) {
              print('  Created new local timer state for $timerId');
            }
          }

          // Update from Firebase data
          timerState.updateFromFirestore(data);

          // Sync stopwatch state
          final shouldBeRunning = data['isRunning'] ?? false;
          if (kDebugMode) {
            print('');
            print('üîµüîµüîµ TIMER SYNC CHECK üîµüîµüîµ');
            print('Timer ID: $timerId');
            print('Should be running: $shouldBeRunning');
            print('üîµüîµüîµüîµüîµüîµüîµüîµüîµüîµüîµüîµüîµ');
            print('');
          }
          if (shouldBeRunning) {
            // Calculate server elapsed time
            int serverElapsed = data['elapsedMilliseconds'] ?? 0;
            if (data['lastStartTime'] != null) {
              try {
                final startTime = DateTime.parse(data['lastStartTime']);
                final runningDuration = DateTime.now().difference(startTime);
                serverElapsed += runningDuration.inMilliseconds;
                if (kDebugMode) {
                  print('üü¢üü¢üü¢ STARTING TIMER üü¢üü¢üü¢');
                  print('Base elapsed: ${data['elapsedMilliseconds']}ms');
                  print(
                      'Running duration: ${runningDuration.inMilliseconds}ms');
                  print('Total elapsed: ${serverElapsed}ms');
                  print('üü¢üü¢üü¢üü¢üü¢üü¢üü¢üü¢üü¢üü¢üü¢');
                }
              } catch (e) {
                if (kDebugMode) print('Error parsing time: $e');
              }
            }

            // Start the timer locally
            timerState.stopwatch.reset();
            timerState.stopwatch.start();
            timerState.stopwatchOffset = serverElapsed;

            // Set initial display value immediately
            timerState.timerValue = _formatTime(serverElapsed);

            // Sync lap stopwatch - calculate current lap elapsed time
            int remoteLapElapsed = data['lapElapsedMilliseconds'] ?? 0;
            if (data['lastLapStartTime'] != null) {
              try {
                final lapStartTime = DateTime.parse(data['lastLapStartTime']);
                final lapRunningDuration =
                    DateTime.now().difference(lapStartTime);
                remoteLapElapsed += lapRunningDuration.inMilliseconds;
                if (kDebugMode) {
                  print(
                      'üïê Lap running duration: ${lapRunningDuration.inMilliseconds}ms, total lap elapsed: ${remoteLapElapsed}ms');
                }
              } catch (e) {
                if (kDebugMode) print('Error parsing lap start time: $e');
              }
            }
            timerState.lapStopwatch.reset();
            timerState.lapStopwatch.start();
            timerState.lapStopwatchOffset = remoteLapElapsed;

            // Set initial lap display value immediately
            timerState.currentLapTimeValue = _formatTime(remoteLapElapsed);

            timerState.isRunning = true;

            // Start periodic timer for UI updates
            timerState.periodicTimer?.cancel();
            final capturedTimerState = timerState; // Capture for closure
            if (kDebugMode) {
              print('üü°üü°üü° Creating periodic timer for UI updates üü°üü°üü°');
            }
            timerState.periodicTimer =
                Timer.periodic(const Duration(milliseconds: 10), (timer) {
              if (mounted) {
                int actualElapsed =
                    capturedTimerState.stopwatch.elapsedMilliseconds +
                        capturedTimerState.stopwatchOffset;
                capturedTimerState.timerValue = _formatTime(actualElapsed);
                int actualLapElapsed =
                    capturedTimerState.lapStopwatch.elapsedMilliseconds +
                        capturedTimerState.lapStopwatchOffset;
                capturedTimerState.currentLapTimeValue =
                    _formatTime(actualLapElapsed);
                setState(() {});
              } else {
                timer.cancel();
              }
            });

            if (kDebugMode) {
              print('‚úÖ Started timer $timerId from Firebase state');
              print('Initial display value: ${timerState.timerValue}');
              print('Stopwatch running: ${timerState.stopwatch.isRunning}');
              print('Stopwatch offset: ${timerState.stopwatchOffset}');
              print(
                  'Periodic timer created: ${timerState.periodicTimer != null}');
            }

            // Force immediate UI update
            if (mounted) {
              setState(() {});
            }
          } else {
            // Timer is stopped - just update display values
            int serverElapsed = data['elapsedMilliseconds'] ?? 0;
            timerState.stopwatchOffset =
                serverElapsed - timerState.stopwatch.elapsedMilliseconds;
            timerState.timerValue = _formatTime(serverElapsed);

            int remoteLapElapsed = data['lapElapsedMilliseconds'] ?? 0;
            timerState.lapStopwatchOffset =
                remoteLapElapsed - timerState.lapStopwatch.elapsedMilliseconds;
            timerState.currentLapTimeValue = _formatTime(remoteLapElapsed);
          }
        }

        // Extract runner names from loaded timer IDs and update local list
        // Timer IDs are in format: timer_0_RunnerName
        List<String> extractedRunnerNames = [];
        Map<int, String> indexedRunners = {};

        for (String timerId in firebaseTimerIds) {
          // Parse timer ID: timer_<index>_<runnerName>
          final parts = timerId.split('_');
          if (parts.length >= 3) {
            try {
              int index = int.parse(parts[1]);
              String runnerName = parts.sublist(2).join('_');
              indexedRunners[index] = runnerName;
            } catch (e) {
              if (kDebugMode) print('Error parsing timer ID $timerId: $e');
            }
          }
        }

        // Sort by index and extract runner names
        var sortedIndices = indexedRunners.keys.toList()..sort();
        for (int index in sortedIndices) {
          extractedRunnerNames.add(indexedRunners[index]!);
        }

        // Update local runner names if we extracted any
        if (extractedRunnerNames.isNotEmpty) {
          if (kDebugMode) {
            print(
                'üìù Updating runner names from Firebase: $extractedRunnerNames');
          }
          runnerNames = extractedRunnerNames;

          // IMPORTANT: Don't save to SharedPreferences if we're in an active joined session
          // We want to preserve the original runner names for when we quit
          final prefs = await SharedPreferences.getInstance();
          bool wasInActiveSession =
              prefs.getBool('was_in_active_session') ?? false;

          if (!wasInActiveSession) {
            // Only save if this is our own session (not a joined session)
            await prefs.setStringList('runner_names', runnerNames);
            if (kDebugMode) {
              print('üíæ Saved runner names to SharedPreferences');
            }
          } else {
            if (kDebugMode) {
              print(
                  '‚è≠Ô∏è Skipped saving runner names (in active session, preserving backup)');
            }
          }

          // Regenerate ALL row keys when loading from Firebase
          // We can't reuse keys because runner order may have changed
          if (kDebugMode) {
            print(
                'üîë Regenerating all row keys for synced session (${runnerNames.length} runners)');
          }
          rowKeys = List.generate(
            runnerNames.length,
            (_) => GlobalKey<_TimerRowState>(),
          );

          if (kDebugMode) {
            print('‚è≥ Waiting 50ms for periodic timers to start');
          }
          // Give periodic timers a moment to fire before building UI
          await Future.delayed(Duration(milliseconds: 50));
        }

        if (mounted) {
          if (kDebugMode) {
            print(
                'üîÑ Triggering immediate UI update with initial timer values');
            print('   Current timerStates count: ${timerStates.length}');
            print('   Runner names count: ${runnerNames.length}');
            print('   Timer IDs in map: ${timerStates.keys.toList()}');
          }
          // Force immediate UI update - timer values are already set
          setState(() {});
        }
      }

      if (kDebugMode) {
        print('‚úÖ Initial sync complete');
      }
    } catch (e) {
      if (kDebugMode) {
        print('‚ùå Error during initial sync: $e');
      }
    }
  }

  // Initialize Firebase real-time listeners
  void _initializeFirebaseListeners() {
    // Set flag to ignore initial snapshot to avoid flash
    _justCompletedInitialSync = true;
    Future.delayed(Duration(milliseconds: 2000), () {
      _justCompletedInitialSync = false;
      if (kDebugMode) {
        print('‚úÖ Skip window expired - forcing UI rebuild');
        // Debug: Check timer states
        for (var entry in timerStates.entries) {
          final state = entry.value;
          print('Timer ${entry.key}: isRunning=${state.isRunning}, '
              'stopwatch.isRunning=${state.stopwatch.isRunning}, '
              'periodicTimer=${state.periodicTimer != null}, '
              'value=${state.timerValue}');
        }
      }
      // Force rebuild to ensure periodic timers are connected to UI
      if (mounted) {
        setState(() {});
      }
    });

    // Cancel existing listener before creating new one
    _timersListener?.cancel();

    final firestore = FirebaseFirestore.instance;

    if (kDebugMode) {
      print('üî• Firebase listener initialized for session: $TIMER_SESSION_ID');
    }

    // Listen to all timer states in this session
    _timersListener = firestore
        .collection('timer_sessions')
        .doc(TIMER_SESSION_ID)
        .collection('timers')
        .snapshots()
        .listen((snapshot) {
      // Skip processing if we just completed initial sync to avoid flash
      if (_justCompletedInitialSync) {
        if (kDebugMode) {
          print('‚è≠Ô∏è Skipping listener update - just completed initial sync');
        }
        return;
      }

      if (kDebugMode) {
        print(
            'üî• Received ${snapshot.docChanges.length} changes from Firebase');
      }

      for (var change in snapshot.docChanges) {
        if (change.type == DocumentChangeType.added ||
            change.type == DocumentChangeType.modified) {
          final data = change.doc.data();
          if (data != null) {
            final timerId = change.doc.id;

            if (kDebugMode) {
              print(
                  'üî• Update for timer: $timerId, isRunning: ${data['isRunning']}');
            }

            // Find or create timer state
            TimerState? timerState = timerStates[timerId];
            if (timerState != null) {
              // Check if this action was from this user (skip echo)
              String? actionUserId = data['lastActionUserId'];

              if (kDebugMode) {
                print(
                    'üîç Timer update: $timerId, actionUserId: $actionUserId, currentUserId: $_currentUserId');
              }

              if (actionUserId != null && actionUserId == _currentUserId) {
                // This is an echo of our own action - skip it
                if (kDebugMode) {
                  print('‚è≠Ô∏è Skipping own update for $timerId (userId match)');
                }
                continue;
              }

              // Show indicator that another user performed this action
              if (actionUserId != null && actionUserId != _currentUserId) {
                if (kDebugMode) {
                  print('üë§ Remote action from user: $actionUserId');
                  print(
                      '   isRunning: ${data['isRunning']}, elapsed: ${data['elapsedMilliseconds']}');
                }
                // Determine action type from data
                String? actionType;
                if (data['isRunning'] == true) {
                  actionType = 'started';
                } else if (data['isRunning'] == false) {
                  if (data['elapsedMilliseconds'] == 0) {
                    actionType = 'reset';
                  } else {
                    actionType = 'stopped';
                  }
                }
                if (kDebugMode) {
                  print('   Action type detected: $actionType');
                }
                _showRemoteActionIndicator(actionUserId,
                    action: actionType, timerId: timerId);
              }

              if (kDebugMode) {
                print('‚úÖ Applying remote update to $timerId');
              }

              // Update timer state from Firebase
              timerState.updateFromFirestore(data);

              // Sync local stopwatch with remote state
              final shouldBeRunning = data['isRunning'] ?? false;
              final isCurrentlyRunning = timerState.stopwatch.isRunning;

              if (shouldBeRunning && !isCurrentlyRunning) {
                // Remote timer started - start locally
                if (kDebugMode) {
                  print('‚ñ∂Ô∏è Starting timer $timerId from remote');
                }

                // Calculate server elapsed time
                int serverElapsed = data['elapsedMilliseconds'] ?? 0;
                if (data['lastStartTime'] != null) {
                  try {
                    final startTime = DateTime.parse(data['lastStartTime']);
                    final runningDuration =
                        DateTime.now().difference(startTime);
                    serverElapsed += runningDuration.inMilliseconds;
                  } catch (e) {
                    if (kDebugMode) print('Error parsing time: $e');
                  }
                }

                if (kDebugMode) {
                  print('üïê Server elapsed time: ${serverElapsed}ms');
                }

                // Reset and start stopwatch, then set offset to match server time
                timerState.stopwatch.reset();
                timerState.stopwatch.start();
                timerState.stopwatchOffset = serverElapsed;

                // Also sync lap stopwatch - calculate current lap elapsed time
                int remoteLapElapsed = data['lapElapsedMilliseconds'] ?? 0;
                if (data['lastLapStartTime'] != null) {
                  try {
                    final lapStartTime =
                        DateTime.parse(data['lastLapStartTime']);
                    final lapRunningDuration =
                        DateTime.now().difference(lapStartTime);
                    remoteLapElapsed += lapRunningDuration.inMilliseconds;
                  } catch (e) {
                    if (kDebugMode) print('Error parsing lap start time: $e');
                  }
                }
                timerState.lapStopwatch.reset();
                timerState.lapStopwatch.start();
                timerState.lapStopwatchOffset = remoteLapElapsed;

                _startTimer(timerState, syncToFirebase: false);
              } else if (!shouldBeRunning && isCurrentlyRunning) {
                // Remote timer stopped - stop locally
                if (kDebugMode) {
                  print('‚èπÔ∏è Stopping timer $timerId from remote');
                }

                // Stop the timers
                timerState.stopwatch.stop();
                timerState.lapStopwatch.stop();
                timerState.isRunning = false;
                timerState.periodicTimer?.cancel();

                // Update offset to preserve final time
                timerState.stopwatchOffset =
                    (data['elapsedMilliseconds'] ?? 0) -
                        timerState.stopwatch.elapsedMilliseconds;

                // Update lap stopwatch offset to match remote lap time
                int remoteLapElapsed = data['lapElapsedMilliseconds'] ?? 0;
                timerState.lapStopwatchOffset = remoteLapElapsed -
                    timerState.lapStopwatch.elapsedMilliseconds;

                // Update the display value
                timerState.timerValue =
                    _formatTime(data['elapsedMilliseconds'] ?? 0);
                timerState.currentLapTimeValue = _formatTime(remoteLapElapsed);

                if (kDebugMode) {
                  print(
                      '‚úÖ Timer $timerId stopped, final time: ${timerState.timerValue}');
                }
              } else if (shouldBeRunning && isCurrentlyRunning) {
                // Both running - sync to the timer with MORE elapsed time
                int serverElapsed = data['elapsedMilliseconds'] ?? 0;
                if (data['lastStartTime'] != null) {
                  try {
                    final startTime = DateTime.parse(data['lastStartTime']);
                    final runningDuration =
                        DateTime.now().difference(startTime);
                    serverElapsed += runningDuration.inMilliseconds;
                  } catch (e) {
                    if (kDebugMode) print('Error parsing time: $e');
                  }
                }

                int localElapsed = timerState.stopwatch.elapsedMilliseconds +
                    timerState.stopwatchOffset;

                // Only sync if server time is greater (avoid going backwards)
                if (serverElapsed > localElapsed) {
                  if (kDebugMode) {
                    print(
                        '‚è±Ô∏è Syncing to server time: $serverElapsed ms (local was $localElapsed ms)');
                  }
                  timerState.stopwatchOffset =
                      serverElapsed - timerState.stopwatch.elapsedMilliseconds;
                } else {
                  if (kDebugMode) {
                    print(
                        '‚è≠Ô∏è Keeping local time: $localElapsed ms (server was $serverElapsed ms)');
                  }
                }

                // Also sync lap stopwatch state
                int remoteLapElapsed = data['lapElapsedMilliseconds'] ?? 0;
                int localLapElapsed =
                    timerState.lapStopwatch.elapsedMilliseconds +
                        timerState.lapStopwatchOffset;

                // If remote lap elapsed is significantly different, sync it
                // This handles the case where a lap was taken remotely
                if ((remoteLapElapsed - localLapElapsed).abs() > 100) {
                  // 100ms tolerance
                  if (kDebugMode) {
                    print(
                        '‚è±Ô∏è Syncing lap time: $remoteLapElapsed ms (local was $localLapElapsed ms)');
                  }
                  timerState.lapStopwatchOffset = remoteLapElapsed -
                      timerState.lapStopwatch.elapsedMilliseconds;
                }
              } else if (!shouldBeRunning && !isCurrentlyRunning) {
                // Both stopped - update displayed time
                int serverElapsed = data['elapsedMilliseconds'] ?? 0;
                timerState.stopwatchOffset =
                    serverElapsed - timerState.stopwatch.elapsedMilliseconds;
                timerState.timerValue = _formatTime(serverElapsed);

                // Also update lap stopwatch offset
                int remoteLapElapsed = data['lapElapsedMilliseconds'] ?? 0;
                timerState.lapStopwatchOffset = remoteLapElapsed -
                    timerState.lapStopwatch.elapsedMilliseconds;
                timerState.currentLapTimeValue = _formatTime(remoteLapElapsed);
              }

              // Force UI update
              if (mounted) {
                setState(() {});
              }
            }
          }
        }
      }
    }, onError: (error) {
      if (kDebugMode) {
        print('‚ùå Firebase listener error: $error');
      }
    });
  }

  // Sync timer state to Firebase
  Future<void> _syncToFirebase(TimerState timerState) async {
    if (timerState.isSyncing) {
      if (kDebugMode) {
        print('‚è∏Ô∏è Skipping sync for ${timerState.id} - already syncing');
      }
      return;
    }

    try {
      timerState.isSyncing = true;

      // Update elapsed time if running
      if (timerState.isRunning) {
        timerState.elapsedMilliseconds =
            timerState.stopwatch.elapsedMilliseconds +
                timerState.stopwatchOffset;
        timerState.lastStartTime = DateTime.now();
        // Also update lap start time if lap stopwatch is running
        if (timerState.lapStopwatch.isRunning) {
          timerState.lastLapStartTime = DateTime.now();
        }
      } else {
        timerState.elapsedMilliseconds =
            timerState.stopwatch.elapsedMilliseconds +
                timerState.stopwatchOffset;
        timerState.lastStartTime = null;
        timerState.lastLapStartTime = null;
      }

      if (kDebugMode) {
        print(
            'üì§ Syncing ${timerState.id} to Firebase: isRunning=${timerState.isRunning}, elapsed=${timerState.elapsedMilliseconds}ms, userId=$_currentUserId');
      }

      final firestore = FirebaseFirestore.instance;
      final data = timerState.toFirestore();

      // Ensure we have a user ID
      if (_currentUserId.isEmpty) {
        if (kDebugMode) {
          print('‚ö†Ô∏è Warning: _currentUserId is empty, using fallback');
        }
        data['lastActionUserId'] = 'unknown';
      } else {
        data['lastActionUserId'] = _currentUserId;
      }

      await firestore
          .collection('timer_sessions')
          .doc(TIMER_SESSION_ID)
          .collection('timers')
          .doc(timerState.id)
          .set(data, SetOptions(merge: true));

      if (kDebugMode) {
        print('‚úÖ Sync complete for ${timerState.id}');
      }
    } catch (e) {
      if (kDebugMode) {
        print('‚ùå Error syncing to Firebase: $e');
      }
    } finally {
      timerState.isSyncing = false;
    }
  }

  String _getTimerStateId(int index) {
    return 'timer_${index}_${runnerNames[index]}';
  }

  TimerState _getTimerState(int index) {
    String timerId = _getTimerStateId(index);
    if (!timerStates.containsKey(timerId)) {
      if (kDebugMode) {
        print('‚ö†Ô∏è Creating NEW timer state for $timerId (not found in map)');
        print('   Available timer IDs: ${timerStates.keys.toList()}');
      }
      timerStates[timerId] = TimerState(timerId);
    }
    return timerStates[timerId]!;
  }

  void _remapTimerStatesAfterReorder() {
    // Create a new map with updated timer state IDs based on current order
    Map<String, TimerState> newTimerStates = {};

    // For each runner in the current order, find their timer state by runner name
    for (int i = 0; i < runnerNames.length; i++) {
      String runnerName = runnerNames[i];
      String newTimerId = _getTimerStateId(i);

      // Find existing timer state for this runner (search by runner name)
      TimerState? existingState;
      for (var entry in timerStates.entries) {
        if (entry.key.endsWith('_$runnerName')) {
          existingState = entry.value;
          break;
        }
      }

      // If found, use existing state; otherwise create new one
      if (existingState != null) {
        newTimerStates[newTimerId] = existingState;
      } else {
        newTimerStates[newTimerId] = TimerState(newTimerId);
      }
    }

    // Dispose old timer states that are no longer used
    for (var entry in timerStates.entries) {
      if (!newTimerStates.containsValue(entry.value)) {
        entry.value.dispose();
      }
    }

    // Replace the old timer states map
    timerStates = newTimerStates;
  }

  void startAllTimers() {
    for (int i = 0; i < runnerNames.length; i++) {
      String timerId = _getTimerStateId(i);
      TimerState? timerState = timerStates[timerId];
      if (timerState != null) {
        _startTimer(timerState);
      }
    }
  }

  void stopAllTimers() {
    for (int i = 0; i < runnerNames.length; i++) {
      String timerId = _getTimerStateId(i);
      TimerState? timerState = timerStates[timerId];
      if (timerState != null) {
        _stopTimer(timerState);
      }
    }
  }

  void resetAllTimers() {
    for (int i = 0; i < runnerNames.length; i++) {
      String timerId = _getTimerStateId(i);
      TimerState? timerState = timerStates[timerId];
      if (timerState != null) {
        _resetTimer(timerState);
      }
    }
    // Additional UI update after resetting all timers
    if (mounted) {
      setState(() {});
    }
  }

  void _startTimer(TimerState timerState, {bool syncToFirebase = true}) async {
    if (kDebugMode) {
      print(
          'üé¨ _startTimer called for ${timerState.id}, syncToFirebase: $syncToFirebase');
    }
    // If syncing to Firebase, check for existing state first
    if (syncToFirebase) {
      try {
        final doc = await FirebaseFirestore.instance
            .collection('timer_sessions')
            .doc(TIMER_SESSION_ID)
            .collection('timers')
            .doc(timerState.id)
            .get();

        if (doc.exists) {
          final data = doc.data();
          if (data != null && (data['isRunning'] ?? false)) {
            // Timer is already running remotely, sync to it instead of starting fresh
            if (kDebugMode) {
              print(
                  'üîÑ Timer ${timerState.id} already running remotely, syncing instead of starting fresh');
            }

            timerState.updateFromFirestore(data);

            // Calculate current server time
            int serverElapsed = data['elapsedMilliseconds'] ?? 0;
            if (data['lastStartTime'] != null) {
              try {
                final startTime = DateTime.parse(data['lastStartTime']);
                final runningDuration = DateTime.now().difference(startTime);
                serverElapsed += runningDuration.inMilliseconds;
              } catch (e) {
                if (kDebugMode) print('Error parsing time: $e');
              }
            }

            // Start local stopwatch and set offset to match server
            timerState.stopwatch.reset();
            timerState.stopwatch.start();
            timerState.stopwatchOffset = serverElapsed;
            timerState.isRunning = true;

            // Calculate current lap elapsed time
            int remoteLapElapsed = data['lapElapsedMilliseconds'] ?? 0;
            if (data['lastLapStartTime'] != null) {
              try {
                final lapStartTime = DateTime.parse(data['lastLapStartTime']);
                final lapRunningDuration =
                    DateTime.now().difference(lapStartTime);
                remoteLapElapsed += lapRunningDuration.inMilliseconds;
              } catch (e) {
                if (kDebugMode) print('Error parsing lap start time: $e');
              }
            }
            timerState.lapStopwatch.reset();
            timerState.lapStopwatch.start();
            timerState.lapStopwatchOffset = remoteLapElapsed;

            // Start the periodic timer for UI updates
            timerState.periodicTimer?.cancel();
            timerState.periodicTimer =
                Timer.periodic(const Duration(milliseconds: 10), (timer) {
              if (mounted) {
                int actualElapsed = timerState.stopwatch.elapsedMilliseconds +
                    timerState.stopwatchOffset;
                timerState.timerValue = _formatTime(actualElapsed);
                int actualLapElapsed =
                    timerState.lapStopwatch.elapsedMilliseconds +
                        timerState.lapStopwatchOffset;
                timerState.currentLapTimeValue = _formatTime(actualLapElapsed);
                setState(() {});
              } else {
                timer.cancel();
              }
            });

            if (mounted) setState(() {});
            return; // Don't start fresh, we've synced
          }
        }
      } catch (e) {
        if (kDebugMode) {
          print('Error checking remote timer state: $e');
        }
      }
    }

    // Normal start (timer not running remotely)
    timerState.stopwatch.start();
    timerState.lapStopwatch.start();
    timerState.isRunning = true;
    timerState.periodicTimer?.cancel();
    timerState.periodicTimer =
        Timer.periodic(const Duration(milliseconds: 10), (timer) {
      if (mounted) {
        // Use stopwatch elapsed time + offset for accurate time display
        int actualElapsed = timerState.stopwatch.elapsedMilliseconds +
            timerState.stopwatchOffset;
        timerState.timerValue = _formatTime(actualElapsed);
        int actualLapElapsed = timerState.lapStopwatch.elapsedMilliseconds +
            timerState.lapStopwatchOffset;
        timerState.currentLapTimeValue = _formatTime(actualLapElapsed);
        setState(() {}); // Trigger rebuild to update UI
      } else {
        timer.cancel();
      }
    });

    // Sync to Firebase
    if (syncToFirebase) {
      if (kDebugMode) {
        print('üì§ Calling _syncToFirebase for ${timerState.id}');
      }
      _syncToFirebase(timerState);
    } else {
      if (kDebugMode) {
        print('‚è≠Ô∏è Skipping Firebase sync for ${timerState.id}');
      }
    }
  }

  void _takeLapTime(TimerState timerState, {bool syncToFirebase = true}) {
    if (timerState.isRunning) {
      final currentTimerValue = timerState.timerValue;
      final lapTime =
          _calculateLapTime(currentTimerValue, timerState.previousTime);
      final splitTime = currentTimerValue;
      timerState.previousTime = currentTimerValue;
      timerState.lapNumber++;
      timerState.lapEntries
          .insert(0, LapEntry(lapTime: lapTime, splitTime: splitTime));
      // Reset lap timer and offset
      timerState.lapStopwatch.reset();
      timerState.lapStopwatch.start();
      timerState.lapStopwatchOffset = 0; // Reset offset when taking a lap
      timerState.lastLapStartTime = DateTime.now(); // Track when lap started
      timerState.currentLapNumber = timerState.lapNumber + 1;
      timerState.currentLapTimeValue = '00:00:00';
      setState(() {}); // Trigger UI update

      // Sync to Firebase
      if (syncToFirebase) {
        _syncToFirebase(timerState);
      }
    }
  }

  String _calculateLapTime(String currentTimerValue, String previousTime) {
    final currentDuration = _timeStringToDuration(currentTimerValue);
    final previousDuration = _timeStringToDuration(previousTime);
    final lapDuration = currentDuration - previousDuration;
    final int ms = ((lapDuration.inMilliseconds % 1000) ~/ 10);
    final String lapTime =
        '${lapDuration.inMinutes.toString().padLeft(2, '0')}:'
        '${(lapDuration.inSeconds % 60).toString().padLeft(2, '0')}:'
        '${ms.toString().padLeft(2, '0')}';
    return lapTime;
  }

  Duration _timeStringToDuration(String timeString) {
    final List<String> timeComponents = timeString.split(':');
    final int minutes = int.parse(timeComponents[0]);
    final int seconds = int.parse(timeComponents[1]);
    final int centiseconds = int.parse(timeComponents[2]);
    return Duration(
        minutes: minutes, seconds: seconds, milliseconds: centiseconds * 10);
  }

  void _stopTimer(TimerState timerState, {bool syncToFirebase = true}) {
    if (timerState.isRunning) {
      // Take a final lap time before stopping (don't sync yet)
      _takeLapTime(timerState, syncToFirebase: false);
    }
    timerState.stopwatch.stop();
    timerState.lapStopwatch.stop();
    timerState.isRunning = false;
    timerState.periodicTimer?.cancel();

    if (kDebugMode) {
      print('üõë Stopping timer ${timerState.id} locally');
    }

    setState(() {}); // Trigger UI update

    // Sync to Firebase (this will include the lap time from above)
    if (syncToFirebase) {
      _syncToFirebase(timerState);
    }
  }

  void _resetTimer(TimerState timerState, {bool syncToFirebase = true}) {
    // Cancel any running timer first
    timerState.periodicTimer?.cancel();
    timerState.periodicTimer = null;

    // Reset all stopwatch instances
    timerState.stopwatch.reset();
    timerState.lapStopwatch.reset();

    // Reset all state variables
    timerState.isRunning = false;
    timerState.timerValue = '00:00:00';
    timerState.currentLapTimeValue = '00:00:00';
    timerState.previousTime = '00:00:00';
    timerState.lapEntries.clear();
    timerState.currentLapNumber = 1;
    timerState.lapNumber = 0;
    timerState.elapsedMilliseconds = 0;
    timerState.lastStartTime = null;
    timerState.stopwatchOffset = 0;
    timerState.lapStopwatchOffset = 0;

    // Force UI update to reflect reset state
    if (mounted) {
      setState(() {});
    }

    // Sync to Firebase
    if (syncToFirebase) {
      _syncToFirebase(timerState);
    }
  }

  String _formatTime(int milliseconds) {
    // Convert to centiseconds (1/100 second) format: MM:SS:CC
    final int centiseconds = (milliseconds / 10).truncate();
    final int seconds = (centiseconds / 100).truncate();
    final int minutes = (seconds / 60).truncate();
    final String centisecondsStr =
        (centiseconds % 100).toString().padLeft(2, '0');
    final String secondsStr = (seconds % 60).toString().padLeft(2, '0');
    final String minutesStr = (minutes % 60).toString().padLeft(2, '0');
    return '$minutesStr:$secondsStr:$centisecondsStr';
  }

  // Pace calculation helper functions
  String _formatPaceDisplay(double paceValue) {
    final minutes = paceValue.floor();
    final seconds = ((paceValue - minutes) * 60).round();
    return '${minutes}:${seconds.toString().padLeft(2, '0')}';
  }

  String _formatTimeFromSeconds(double totalSeconds) {
    final hours = (totalSeconds / 3600).floor();
    final minutes = ((totalSeconds % 3600) / 60).floor();
    final seconds = (totalSeconds % 60).floor();

    if (hours > 0) {
      return '${hours}:${minutes.toString().padLeft(2, '0')}:${seconds.toString().padLeft(2, '0')}';
    } else {
      return '${minutes}:${seconds.toString().padLeft(2, '0')}';
    }
  }

  double _calculateTimeForDistance(int distanceInMeters) {
    // Convert pace value to seconds per meter
    final pacePerKmInSeconds = _paceValue * 60; // Convert minutes to seconds
    final pacePerMeterInSeconds = pacePerKmInSeconds / 1000.0;

    // Calculate total time for the distance
    return distanceInMeters * pacePerMeterInSeconds;
  }

  void _finishEditingPace() {
    setState(() {
      _isEditingPace = false;
      // Parse the entered pace value
      final paceText = _paceController.text.trim();
      final pacePattern = RegExp(r'^(\d+):([0-5]\d)$');
      final match = pacePattern.firstMatch(paceText);

      if (match != null) {
        final minutes = int.parse(match.group(1)!);
        final seconds = int.parse(match.group(2)!);
        final newPaceValue = minutes + (seconds / 60.0);

        // Clamp to valid range
        _paceValue = newPaceValue.clamp(2.0, 10.0);
      }

      // Update controller with formatted value
      _paceController.text = _formatPaceDisplay(_paceValue);
    });
  }

  void _startEditingPace() {
    setState(() {
      _isEditingPace = true;
      _paceController.text = _formatPaceDisplay(_paceValue);
    });
    _paceFocusNode.requestFocus();
  }

  void _adjustPaceValue(double adjustment) async {
    final int currentPaceSeconds = (_paceValue * 60).round();
    final int adjustmentSeconds =
        (adjustment * 3).round(); // 3 seconds per unit for sensitivity
    final int newPaceSeconds = (currentPaceSeconds + adjustmentSeconds)
        .clamp(120, 600); // 2:00 to 10:00

    setState(() {
      _paceValue = newPaceSeconds / 60.0;
    });

    // Throttled haptic feedback
    final now = DateTime.now();
    if (_lastHapticTime == null ||
        now.difference(_lastHapticTime!).inMilliseconds > 50) {
      HapticFeedback.selectionClick();
      _lastHapticTime = now;
    }
  }

  void _showPaceEditDialog() {
    final TextEditingController dialogController = TextEditingController(
      text: _formatPaceDisplay(_paceValue),
    );

    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: Text('Edit Pace per KM'),
          content: TextField(
            controller: dialogController,
            decoration: InputDecoration(
              labelText: 'Pace (MM:SS)',
              hintText: 'e.g., 4:30',
            ),
            keyboardType: TextInputType.text,
            autofocus: true,
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: Text('Cancel'),
            ),
            TextButton(
              onPressed: () {
                _updatePaceFromDialog(dialogController.text);
                Navigator.of(context).pop();
              },
              child: Text('Save'),
            ),
          ],
        );
      },
    );
  }

  void _updatePaceFromDialog(String paceText) {
    try {
      final parts = paceText.split(':');
      if (parts.length == 2) {
        final minutes = int.parse(parts[0]);
        final seconds = int.parse(parts[1]);
        final totalMinutes = minutes + (seconds / 60.0);
        final clampedPace = totalMinutes.clamp(2.0, 10.0);

        setState(() {
          _paceValue = clampedPace;
          _isEditingPace = false;
        });
      }
    } catch (e) {
      // Invalid format, ignore
    }
  }

  void _startEditingDistance(String distanceName, String currentTime) {
    setState(() {
      _editingDistance = distanceName;
      _distanceControllers[distanceName]?.text = currentTime;
    });
  }

  void _adjustDistanceTime(
      String distanceName, int distanceInMeters, int adjustment) async {
    // Add throttled haptic feedback for drag adjustments
    if (adjustment != 0) {
      final now = DateTime.now();
      if (_lastDragTime == null ||
          now.difference(_lastDragTime!).inMilliseconds > 100) {
        await performHapticFeedback();
        _lastDragTime = now;
      }
    }

    // Calculate current time for this distance
    final currentTimeInSeconds = _calculateTimeForDistance(distanceInMeters);

    // Adjust time by 1 second increments
    final newTimeInSeconds =
        (currentTimeInSeconds + adjustment).clamp(1.0, 86400.0); // Max 24 hours

    // Calculate new pace per km from this adjusted time
    final newPacePerKmInSeconds =
        (newTimeInSeconds * 1000.0) / distanceInMeters;
    final newPaceValue = newPacePerKmInSeconds / 60.0; // Convert to minutes

    // Update pace (this will automatically update all distance times)
    setState(() {
      _paceValue = newPaceValue.clamp(2.0, 10.0);
      _paceController.text = _formatPaceDisplay(_paceValue);
    });
  }

  void _showTimeEditDialog(
      String distanceName, int distanceInMeters, String currentTime) {
    final TextEditingController dialogController =
        TextEditingController(text: currentTime);

    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: Text('Edit $distanceName Time'),
          content: TextField(
            controller: dialogController,
            decoration: InputDecoration(
              labelText: 'Time (MM:SS or H:MM:SS)',
              hintText: 'e.g., 4:30 or 1:25:30',
            ),
            keyboardType: TextInputType.text,
            autofocus: true,
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: Text('Cancel'),
            ),
            TextButton(
              onPressed: () {
                _updateTimeFromDialog(
                    distanceName, distanceInMeters, dialogController.text);
                Navigator.of(context).pop();
              },
              child: Text('Update'),
            ),
          ],
        );
      },
    );
  }

  void _updateTimeFromDialog(
      String distanceName, int distanceInMeters, String timeText) {
    final timeInSeconds = _parseTimeToSeconds(timeText.trim());

    if (timeInSeconds > 0) {
      // Calculate new pace per km from this time
      final newPacePerKmInSeconds = (timeInSeconds * 1000.0) / distanceInMeters;
      final newPaceValue = newPacePerKmInSeconds / 60.0; // Convert to minutes

      // Update pace and exit editing mode
      setState(() {
        _paceValue = newPaceValue.clamp(2.0, 10.0);
        _paceController.text = _formatPaceDisplay(_paceValue);
        _editingDistance = null;
      });
    }
  }

  // Helper function to parse time strings (MM:SS or H:MM:SS) to seconds
  double _parseTimeToSeconds(String timeText) {
    try {
      final parts = timeText.split(':');
      if (parts.length == 2) {
        // MM:SS format
        final minutes = int.parse(parts[0]);
        final seconds = int.parse(parts[1]);
        return (minutes * 60 + seconds).toDouble();
      } else if (parts.length == 3) {
        // H:MM:SS format
        final hours = int.parse(parts[0]);
        final minutes = int.parse(parts[1]);
        final seconds = int.parse(parts[2]);
        return (hours * 3600 + minutes * 60 + seconds).toDouble();
      }
    } catch (e) {
      // Invalid format
    }
    return 0.0;
  }

  void toggleSlidePanel() {
    setState(() {
      _isSlidePageVisible = !_isSlidePageVisible;
      if (_isSlidePageVisible) {
        // Close LAP drawer if it's open
        if (_isLapSlidePageVisible) {
          _isLapSlidePageVisible = false;
          _lapSlideController.reverse();
        }
        _slideController.forward();
      } else {
        _slideController.reverse();
      }
    });
  }

  void toggleLapSlidePanel() {
    setState(() {
      _isLapSlidePageVisible = !_isLapSlidePageVisible;
      if (_isLapSlidePageVisible) {
        // Close PACE drawer if it's open
        if (_isSlidePageVisible) {
          _isSlidePageVisible = false;
          _slideController.reverse();
        }
        _lapSlideController.forward();
      } else {
        _lapSlideController.reverse();
      }
    });
  }

  Widget _buildSlidePanel() {
    return Container(
      decoration: BoxDecoration(
        color: Colors.white,
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.2),
            blurRadius: 8,
            offset: Offset(2, 0),
          ),
        ],
      ),
      child: Column(
        children: [
          // Header - compact for narrow panel
          Container(
            padding: EdgeInsets.symmetric(horizontal: 8, vertical: 10),
            decoration: BoxDecoration(
              color: Color.fromRGBO(243, 134, 32, 1),
              borderRadius: BorderRadius.only(
                bottomLeft: Radius.circular(8),
                bottomRight: Radius.circular(8),
              ),
            ),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Row(
                  children: [
                    Icon(Icons.speed, color: Colors.white, size: 16),
                    SizedBox(width: 4),
                    Text(
                      'PACE',
                      style: TextStyle(
                        color: Colors.white,
                        fontSize: 12,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ],
                ),
                GestureDetector(
                  onTap: toggleSlidePanel,
                  child: Container(
                    padding: EdgeInsets.all(2),
                    child: Icon(Icons.close, color: Colors.white, size: 14),
                  ),
                ),
              ],
            ),
          ),
          // Main pace calculator content
          Expanded(
            child: _buildPaceCalculator(),
          ),
        ],
      ),
    );
  }

  Widget _buildPaceCalculator() {
    return Padding(
      padding: EdgeInsets.all(8),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Pace input section
          Text(
            'Pace per km:',
            style: TextStyle(
              fontSize: 13,
              fontWeight: FontWeight.bold,
            ),
          ),
          SizedBox(height: 8),

          // Pace display and slider control
          Container(
            padding: EdgeInsets.symmetric(horizontal: 8, vertical: 6),
            decoration: BoxDecoration(
              border: Border.all(color: Colors.grey[300]!),
              borderRadius: BorderRadius.circular(4),
            ),
            child: Column(
              children: [
                // Current pace display - editable with drag control
                _isEditingPace
                    ? GestureDetector(
                        onPanUpdate: (details) {
                          // Horizontal drag to adjust pace
                          final double sensitivity =
                              2.0; // Adjust sensitivity (lower = more sensitive)
                          final double adjustment =
                              details.delta.dx / sensitivity;
                          if (adjustment.abs() > 0.5) {
                            _adjustPaceValue(adjustment);
                          }
                        },
                        onTap: () => _showPaceEditDialog(),
                        child: Container(
                          height: 28,
                          decoration: BoxDecoration(
                            border: Border.all(
                                color: Color.fromRGBO(243, 134, 32, 0.6),
                                width: 1),
                            borderRadius: BorderRadius.circular(4),
                            color: Color.fromRGBO(243, 134, 32, 0.1),
                            boxShadow: [
                              BoxShadow(
                                color: Color.fromRGBO(243, 134, 32, 0.3),
                                blurRadius: 2,
                                offset: Offset(0, 1),
                              ),
                            ],
                          ),
                          child: Row(
                            children: [
                              // Left drag indicator
                              Container(
                                width: 10,
                                height: 28,
                                decoration: BoxDecoration(
                                  color: Color.fromRGBO(243, 134, 32, 0.3),
                                  borderRadius: BorderRadius.only(
                                    topLeft: Radius.circular(3),
                                    bottomLeft: Radius.circular(3),
                                  ),
                                ),
                                child: Center(
                                  child: Icon(
                                    Icons.drag_indicator,
                                    size: 8,
                                    color: Color.fromRGBO(243, 134, 32, 1),
                                  ),
                                ),
                              ),
                              // Pace display with drag functionality
                              Expanded(
                                child: Container(
                                  height: 28,
                                  alignment: Alignment.center,
                                  child: Row(
                                    mainAxisAlignment: MainAxisAlignment.center,
                                    children: [
                                      Icon(
                                        Icons.touch_app,
                                        size: 12,
                                        color: Color.fromRGBO(243, 134, 32, 1),
                                      ),
                                      SizedBox(width: 4),
                                      Text(
                                        _formatPaceDisplay(_paceValue),
                                        style: TextStyle(
                                          fontSize: 16,
                                          fontWeight: FontWeight.bold,
                                          color:
                                              Color.fromRGBO(243, 134, 32, 1),
                                        ),
                                      ),
                                    ],
                                  ),
                                ),
                              ),
                              // Right drag indicator
                              Container(
                                width: 10,
                                height: 28,
                                decoration: BoxDecoration(
                                  color: Color.fromRGBO(243, 134, 32, 0.3),
                                  borderRadius: BorderRadius.only(
                                    topRight: Radius.circular(3),
                                    bottomRight: Radius.circular(3),
                                  ),
                                ),
                                child: Center(
                                  child: Icon(
                                    Icons.drag_indicator,
                                    size: 8,
                                    color: Color.fromRGBO(243, 134, 32, 1),
                                  ),
                                ),
                              ),
                            ],
                          ),
                        ),
                      )
                    : GestureDetector(
                        onTap: () => _startEditingPace(),
                        onLongPress: () => _showPaceEditDialog(),
                        child: Container(
                          height: 24,
                          alignment: Alignment.center,
                          decoration: BoxDecoration(
                            borderRadius: BorderRadius.circular(3),
                            color: Color.fromRGBO(243, 134, 32, 0.1),
                          ),
                          child: Row(
                            mainAxisAlignment: MainAxisAlignment.center,
                            children: [
                              Icon(
                                Icons.touch_app,
                                size: 10,
                                color: Color.fromRGBO(243, 134, 32, 0.7),
                              ),
                              SizedBox(width: 2),
                              Text(
                                _formatPaceDisplay(_paceValue),
                                style: TextStyle(
                                  fontSize: 16,
                                  fontWeight: FontWeight.bold,
                                  color: Color.fromRGBO(243, 134, 32, 1),
                                ),
                              ),
                            ],
                          ),
                        ),
                      ),
                SizedBox(height: 4),

                // Slider for pace adjustment
                Container(
                  height: 30,
                  child: SliderTheme(
                    data: SliderTheme.of(context).copyWith(
                      trackHeight: 4,
                      thumbShape: RoundSliderThumbShape(enabledThumbRadius: 8),
                      overlayShape: RoundSliderOverlayShape(overlayRadius: 16),
                      activeTrackColor: Color.fromRGBO(243, 134, 32, 1),
                      inactiveTrackColor: Colors.grey[300],
                      thumbColor: Color.fromRGBO(243, 134, 32, 1),
                      overlayColor: Color.fromRGBO(243, 134, 32, 0.2),
                    ),
                    child: Slider(
                      value: _paceValue,
                      min: 2.0,
                      max: 10.0,
                      divisions:
                          160, // Allows 3-second increments (8 minutes * 60 seconds / 3)
                      onChanged: (value) {
                        setState(() {
                          _paceValue = value;
                        });
                      },
                    ),
                  ),
                ),

                // Range indicator
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text('2:00',
                        style:
                            TextStyle(fontSize: 11, color: Colors.grey[600])),
                    Text('10:00',
                        style:
                            TextStyle(fontSize: 11, color: Colors.grey[600])),
                  ],
                ),
              ],
            ),
          ),

          SizedBox(height: 12),

          // Results section
          Text(
            'Times:',
            style: TextStyle(
              fontSize: 15,
              fontWeight: FontWeight.bold,
            ),
          ),
          SizedBox(height: 4),

          Expanded(
            child: Container(
              width: double.infinity,
              padding: EdgeInsets.all(6),
              decoration: BoxDecoration(
                color: Colors.grey[50],
                borderRadius: BorderRadius.circular(4),
                border: Border.all(color: Colors.grey[200]!),
              ),
              child: SingleChildScrollView(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: _buildDistanceResults(),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }

  List<Widget> _buildDistanceResults() {
    final distances = [
      {'name': '400m', 'meters': 400},
      {'name': '550m', 'meters': 550},
      {'name': '800m', 'meters': 800},
      {'name': '1200m', 'meters': 1200},
      {'name': '1400m', 'meters': 1400},
      {'name': '1600m', 'meters': 1600},
      {'name': '3km', 'meters': 3000},
      {'name': '5km', 'meters': 5000},
      {'name': '10km', 'meters': 10000},
      {'name': 'Half', 'meters': 21097},
      {'name': 'Full', 'meters': 42195},
    ];

    return distances.map((distance) {
      final distanceName = distance['name'] as String;
      final distanceInMeters = distance['meters'] as int;
      final timeInSeconds = _calculateTimeForDistance(distanceInMeters);
      final formattedTime = _formatTimeFromSeconds(timeInSeconds);
      final isEditing = _editingDistance == distanceName;

      return Padding(
        padding: EdgeInsets.symmetric(vertical: 2),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              distanceName,
              style: TextStyle(fontSize: 10, fontWeight: FontWeight.w500),
            ),
            isEditing
                ? GestureDetector(
                    onPanUpdate: (details) {
                      // Horizontal drag to adjust time
                      final double sensitivity = 0.5;
                      final int adjustment =
                          (details.delta.dx / sensitivity).round();
                      if (adjustment != 0) {
                        _adjustDistanceTime(
                            distanceName, distanceInMeters, adjustment);
                      }
                    },
                    onTap: () => _showTimeEditDialog(
                        distanceName, distanceInMeters, formattedTime),
                    child: Container(
                      constraints: BoxConstraints(
                        maxWidth: 85,
                        minWidth: 70,
                      ),
                      height: 24,
                      decoration: BoxDecoration(
                        border: Border.all(
                            color: Color.fromRGBO(243, 134, 32, 0.6), width: 1),
                        borderRadius: BorderRadius.circular(3),
                        color: Color.fromRGBO(243, 134, 32, 0.1),
                        boxShadow: [
                          BoxShadow(
                            color: Color.fromRGBO(243, 134, 32, 0.3),
                            blurRadius: 2,
                            offset: Offset(0, 1),
                          ),
                        ],
                      ),
                      child: ClipRRect(
                        borderRadius: BorderRadius.circular(3),
                        child: LayoutBuilder(
                          builder: (context, constraints) {
                            return Row(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                // Left drag indicator
                                Container(
                                  width: 5,
                                  height: 22,
                                  decoration: BoxDecoration(
                                    color: Color.fromRGBO(243, 134, 32, 0.3),
                                    borderRadius: BorderRadius.only(
                                      topLeft: Radius.circular(2),
                                      bottomLeft: Radius.circular(2),
                                    ),
                                  ),
                                  child: Icon(
                                    Icons.drag_indicator,
                                    size: 3,
                                    color: Color.fromRGBO(243, 134, 32, 1),
                                  ),
                                ),
                                // Time display with drag functionality
                                Expanded(
                                  child: Container(
                                    height: 22,
                                    constraints: BoxConstraints(
                                      minWidth: 40,
                                    ),
                                    alignment: Alignment.center,
                                    child: FittedBox(
                                      fit: BoxFit.scaleDown,
                                      child: Text(
                                        formattedTime,
                                        style: TextStyle(
                                          fontSize: 10,
                                          fontWeight: FontWeight.bold,
                                          color:
                                              Color.fromRGBO(243, 134, 32, 1),
                                        ),
                                        maxLines: 1,
                                        overflow: TextOverflow.visible,
                                      ),
                                    ),
                                  ),
                                ),
                                // Right drag indicator
                                Container(
                                  width: 5,
                                  height: 22,
                                  decoration: BoxDecoration(
                                    color: Color.fromRGBO(243, 134, 32, 0.3),
                                    borderRadius: BorderRadius.only(
                                      topRight: Radius.circular(2),
                                      bottomRight: Radius.circular(2),
                                    ),
                                  ),
                                  child: Icon(
                                    Icons.drag_indicator,
                                    size: 3,
                                    color: Color.fromRGBO(243, 134, 32, 1),
                                  ),
                                ),
                              ],
                            );
                          },
                        ),
                      ),
                    ),
                  )
                : GestureDetector(
                    onTap: () =>
                        _startEditingDistance(distanceName, formattedTime),
                    onLongPress: () => _showTimeEditDialog(
                        distanceName, distanceInMeters, formattedTime),
                    child: Container(
                      padding: EdgeInsets.symmetric(horizontal: 4, vertical: 2),
                      decoration: BoxDecoration(
                        borderRadius: BorderRadius.circular(3),
                        color: Color.fromRGBO(243, 134, 32, 0.1),
                      ),
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Icon(
                            Icons.touch_app,
                            size: 8,
                            color: Color.fromRGBO(243, 134, 32, 0.7),
                          ),
                          SizedBox(width: 2),
                          Text(
                            formattedTime,
                            style: TextStyle(
                              fontSize: 12,
                              fontWeight: FontWeight.bold,
                              color: Color.fromRGBO(243, 134, 32, 1),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
          ],
        ),
      );
    }).toList();
  }

  Widget _buildLapSlidePanel() {
    return Container(
      decoration: BoxDecoration(
        color: Colors.white,
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.2),
            blurRadius: 8,
            offset: Offset(2, 0),
          ),
        ],
      ),
      child: SafeArea(
        child: Column(
          children: [
            // Header - full width for full screen
            Container(
              padding: EdgeInsets.symmetric(horizontal: 16, vertical: 12),
              decoration: BoxDecoration(
                color: Color.fromRGBO(76, 175, 80, 1), // Green color for LAP
                borderRadius: BorderRadius.only(
                  bottomLeft: Radius.circular(12),
                  bottomRight: Radius.circular(12),
                ),
              ),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Row(
                    children: [
                      Icon(Icons.timer, color: Colors.white, size: 22),
                      SizedBox(width: 8),
                      Text(
                        'LAP TIMES',
                        style: TextStyle(
                          color: Colors.white,
                          fontSize: 16,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ],
                  ),
                  GestureDetector(
                    onTap: toggleLapSlidePanel,
                    child: Container(
                      padding: EdgeInsets.all(8),
                      decoration: BoxDecoration(
                        color: Colors.white.withOpacity(0.2),
                        borderRadius: BorderRadius.circular(6),
                      ),
                      child: Icon(Icons.close, color: Colors.white, size: 20),
                    ),
                  ),
                ],
              ),
            ),
            // Main lap times content
            Expanded(
              child: _buildLapContent(),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildLapContent() {
    return Padding(
      padding: EdgeInsets.all(8),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Lap Times for All Runners:',
            style: TextStyle(
              fontSize: 14,
              fontWeight: FontWeight.bold,
            ),
          ),
          SizedBox(height: 8),
          Expanded(
            child: Container(
              width: double.infinity,
              padding: EdgeInsets.all(8),
              decoration: BoxDecoration(
                color: Colors.grey[50],
                borderRadius: BorderRadius.circular(8),
                border: Border.all(color: Colors.grey[200]!),
              ),
              child: SingleChildScrollView(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    for (int i = 0; i < runnerNames.length; i++)
                      _buildRunnerLapSection(i),
                  ],
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildRunnerLapSection(int runnerIndex) {
    String timerId = _getTimerStateId(runnerIndex);
    var timerState = timerStates[timerId];
    String runnerName = runnerNames[runnerIndex];

    if (timerState == null || timerState.lapEntries.isEmpty) {
      return Container(
        margin: EdgeInsets.symmetric(vertical: 4),
        padding: EdgeInsets.all(12),
        decoration: BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.circular(8),
          border: Border.all(color: Colors.grey[300]!, width: 1),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              runnerName,
              style: TextStyle(
                fontSize: 14,
                fontWeight: FontWeight.bold,
                color: Color.fromRGBO(76, 175, 80, 1),
              ),
            ),
            SizedBox(height: 4),
            Text(
              'No laps recorded',
              style: TextStyle(fontSize: 12, color: Colors.grey[600]),
            ),
          ],
        ),
      );
    }

    return Container(
      margin: EdgeInsets.symmetric(vertical: 4),
      padding: EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.grey[300]!, width: 1),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                runnerName,
                style: TextStyle(
                  fontSize: 14,
                  fontWeight: FontWeight.bold,
                  color: Color.fromRGBO(76, 175, 80, 1),
                ),
              ),
              Text(
                '${timerState.lapEntries.length} laps',
                style: TextStyle(
                  fontSize: 12,
                  color: Colors.grey[600],
                  fontWeight: FontWeight.w500,
                ),
              ),
            ],
          ),
          SizedBox(height: 8),
          ...timerState.lapEntries.asMap().entries.map((entry) {
            int lapIndex = entry.key;
            LapEntry lapEntry = entry.value;
            return Padding(
              padding: EdgeInsets.symmetric(vertical: 2),
              child: Row(
                children: [
                  Container(
                    width: 24,
                    height: 24,
                    decoration: BoxDecoration(
                      color: Color.fromRGBO(76, 175, 80, 1),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Center(
                      child: Text(
                        '${lapIndex + 1}',
                        style: TextStyle(
                          color: Colors.white,
                          fontSize: 10,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                  ),
                  SizedBox(width: 12),
                  Expanded(
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Text(
                          'Lap: ${lapEntry.lapTime}',
                          style: TextStyle(
                              fontSize: 12, fontWeight: FontWeight.w600),
                        ),
                        Text(
                          'Split: ${lapEntry.splitTime}',
                          style:
                              TextStyle(fontSize: 12, color: Colors.grey[600]),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            );
          }).toList(),
        ],
      ),
    );
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _usersListener?.cancel();
    _timersListener?.cancel();
    _heartbeatTimer?.cancel();
    _actionIndicatorTimer?.cancel();
    _removeUserPresence(); // Clean up Firebase presence
    _slideController.dispose();
    _lapSlideController.dispose();
    _paceController.dispose();
    _paceFocusNode.dispose();
    // Dispose distance controllers
    for (var controller in _distanceControllers.values) {
      controller.dispose();
    }
    // Dispose all timer states
    for (var timerState in timerStates.values) {
      timerState.dispose();
    }
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    super.didChangeAppLifecycleState(state);
    if (state == AppLifecycleState.paused ||
        state == AppLifecycleState.detached) {
      // App is being killed or backgrounded
      _removeUserPresence();
    } else if (state == AppLifecycleState.resumed) {
      // App is back to foreground, restore presence
      _updateUserPresence();
    }
  }

  void addTimerRow() {
    setState(() {
      runnerNames.add('Runner ${runnerNames.length + 1}');
      rowKeys.add(GlobalKey<_TimerRowState>());

      // Initialize timer state for new row
      String newTimerId = _getTimerStateId(runnerNames.length - 1);
      timerStates[newTimerId] = TimerState(newTimerId);
    });
  }

  void removeTimerRow(int index) {
    // Clean up timer state before removing
    String timerId = _getTimerStateId(index);
    TimerState? timerState = timerStates[timerId];
    if (timerState != null) {
      timerState.dispose();
      timerStates.remove(timerId);
    }

    setState(() {
      runnerNames.removeAt(index);
      rowKeys.removeAt(index);
    });

    // Reinitialize timer states for remaining rows to maintain correct indices
    _reinitializeTimerStates();
    saveRunnerNames();
  }

  void _reinitializeTimerStates() {
    Map<String, TimerState> newTimerStates = {};
    for (int i = 0; i < runnerNames.length; i++) {
      String newTimerId = _getTimerStateId(i);

      // Try to find existing timer state by runner name
      TimerState? existingState;
      for (var entry in timerStates.entries) {
        if (entry.key.endsWith(runnerNames[i])) {
          existingState = entry.value;
          break;
        }
      }

      if (existingState != null) {
        newTimerStates[newTimerId] = existingState;
      } else {
        newTimerStates[newTimerId] = TimerState(newTimerId);
      }
    }

    // Dispose old timer states that are no longer needed
    for (var entry in timerStates.entries) {
      if (!newTimerStates.containsValue(entry.value)) {
        entry.value.dispose();
      }
    }

    timerStates = newTimerStates;
  }

  Future<void> saveRunnerNames() async {
    try {
      // Save to both SharedPreferences and Document Directory for maximum reliability
      final prefs = await SharedPreferences.getInstance();
      await prefs.setStringList('runnerNames', runnerNames);

      // Also save to document directory (survives app updates)
      await _saveToDocumentDirectory();
    } catch (e) {
      print('Error saving runner names: $e');
    }
  }

  Future<void> loadRunnerNames() async {
    try {
      // First try to load from document directory (survives app updates)
      List<String>? savedNames = await _loadFromDocumentDirectory();

      // If document directory doesn't have data, try SharedPreferences
      if (savedNames == null || savedNames.isEmpty) {
        final prefs = await SharedPreferences.getInstance();
        savedNames = prefs.getStringList('runnerNames');

        // If we found data in SharedPreferences, migrate it to document directory
        if (savedNames != null && savedNames.isNotEmpty) {
          await _saveToDocumentDirectory();
        }
      }

      if (savedNames != null && savedNames.isNotEmpty) {
        setState(() {
          runnerNames = savedNames!;
          rowKeys = List.generate(
            runnerNames.length,
            (_) => GlobalKey<_TimerRowState>(),
          );
        });
        // Reinitialize timer states after loading names
        _initializeTimerStates();
      }
    } catch (e) {
      print('Error loading runner names: $e');
    }
  }

  Future<void> _saveToDocumentDirectory() async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final file = File('${directory.path}/runner_data.json');

      final data = {
        'runnerNames': runnerNames,
        'version': '1.0',
        'lastUpdated': DateTime.now().toIso8601String(),
      };

      await file.writeAsString(json.encode(data));
    } catch (e) {
      print('Error saving to document directory: $e');
    }
  }

  Future<List<String>?> _loadFromDocumentDirectory() async {
    try {
      final directory = await getApplicationDocumentsDirectory();
      final file = File('${directory.path}/runner_data.json');

      if (await file.exists()) {
        final contents = await file.readAsString();
        final data = json.decode(contents) as Map<String, dynamic>;

        if (data['runnerNames'] != null) {
          return List<String>.from(data['runnerNames']);
        }
      }
    } catch (e) {
      print('Error loading from document directory: $e');
    }
    return null;
  }

  @override
  Widget build(BuildContext context) {
    final mediaQuery = MediaQuery.of(context);
    final double screenHeight = mediaQuery.size.height;
    final double screenWidth = mediaQuery.size.width;

    // Responsive app bar height based on screen size - slightly increased for better text fit
    final double appBarHeight =
        screenWidth < 375 ? 56 : 60; // Slightly increased for iPhone 13 mini
    final double totalAppBarHeight = appBarHeight + mediaQuery.padding.top;
    final double availableHeight =
        screenHeight - totalAppBarHeight - mediaQuery.padding.bottom;

    // Improved row height calculation prioritizing 8 rows visibility while maintaining usability
    final double minRowHeight =
        screenWidth < 375 ? 70.0 : 80.0; // Adjusted to fit 8 rows
    final double maxRowHeight =
        screenWidth < 375 ? 110.0 : 130.0; // Reasonable maximum
    final double idealRowsToShow = 8.0; // Always try to show 8 rows
    final double calculatedRowHeight =
        availableHeight / idealRowsToShow; // Prioritize 8 rows
    final double rowHeight =
        calculatedRowHeight.clamp(minRowHeight, maxRowHeight);

    return Scaffold(
      resizeToAvoidBottomInset: true,
      appBar: PreferredSize(
        preferredSize: Size.fromHeight(appBarHeight),
        child: AppBar(
          backgroundColor: Colors.white,
          elevation: 2,
          automaticallyImplyLeading: false,
          titleSpacing: 0,
          toolbarHeight: appBarHeight,
          flexibleSpace: SafeArea(
            child: Container(
              height: appBarHeight,
              padding: EdgeInsets.symmetric(
                  horizontal: 2, vertical: screenWidth < 375 ? 1 : 3),
              child: Row(
                children: [
                  // Logo with transparent background - no color issues!
                  Padding(
                    padding: EdgeInsets.only(
                        left: screenWidth < 375 ? 1.0 : 2.0,
                        right: screenWidth < 375 ? 2.0 : 4.0),
                    child: Image.asset(
                      'assets/RMAC_Text_transparent.png',
                      height: screenWidth < 375 ? 10 : 14,
                      fit: BoxFit.contain,
                    ),
                  ),
                  // Expanded scrollable area for buttons
                  Expanded(
                    child: SingleChildScrollView(
                      scrollDirection: Axis.horizontal,
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.end,
                        children: [
                          if (_isOnlineMode)
                            InkWell(
                              onTap: () {
                                setState(() {
                                  _isUserListVisible = !_isUserListVisible;
                                });
                              },
                              child: Container(
                                margin: EdgeInsets.symmetric(horizontal: 2),
                                padding: EdgeInsets.symmetric(
                                    horizontal: 6, vertical: 2),
                                decoration: BoxDecoration(
                                  color: Colors.green,
                                  borderRadius: BorderRadius.circular(10),
                                ),
                                child: Text(
                                  '${_connectedUsers.length + 1}',
                                  style: TextStyle(
                                    color: Colors.white,
                                    fontSize: 11,
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                              ),
                            ),
                          // Share button
                          IconButton(
                            icon: Icon(Icons.share,
                                size: screenWidth < 375 ? 18 : 20),
                            onPressed: _shareSessionLink,
                            padding: EdgeInsets.zero,
                            constraints: BoxConstraints(
                                minWidth: screenWidth < 375 ? 24 : 32,
                                minHeight: screenWidth < 375 ? 24 : 32),
                            tooltip: 'Share session',
                          ),
                          // Join button
                          IconButton(
                            icon: Icon(Icons.login,
                                size: screenWidth < 375 ? 18 : 20),
                            onPressed: _showJoinSessionDialog,
                            padding: EdgeInsets.zero,
                            constraints: BoxConstraints(
                                minWidth: screenWidth < 375 ? 24 : 32,
                                minHeight: screenWidth < 375 ? 24 : 32),
                            tooltip: 'Join session',
                          ),
                          // Leave session button (only show when in online mode)
                          if (_isOnlineMode)
                            IconButton(
                              icon: Icon(Icons.logout,
                                  size: screenWidth < 375 ? 18 : 20),
                              onPressed: _leaveSession,
                              padding: EdgeInsets.zero,
                              constraints: BoxConstraints(
                                  minWidth: screenWidth < 375 ? 24 : 32,
                                  minHeight: screenWidth < 375 ? 24 : 32),
                              tooltip: 'Leave session',
                            ),
                          // Buttons with minimal spacing
                          IconButton(
                            icon: Icon(Icons.stop,
                                size: screenWidth < 375 ? 18 : 22),
                            onPressed: stopAllTimers,
                            padding: EdgeInsets.zero,
                            constraints: BoxConstraints(
                                minWidth: screenWidth < 375 ? 24 : 32,
                                minHeight: screenWidth < 375 ? 24 : 32),
                          ),
                          IconButton(
                            icon: Icon(Icons.play_arrow,
                                size: screenWidth < 375 ? 18 : 22),
                            onPressed: startAllTimers,
                            padding: EdgeInsets.zero,
                            constraints: BoxConstraints(
                                minWidth: screenWidth < 375 ? 24 : 32,
                                minHeight: screenWidth < 375 ? 24 : 32),
                          ),
                          IconButton(
                            icon: Icon(Icons.refresh,
                                size: screenWidth < 375 ? 18 : 22),
                            onPressed: resetAllTimers,
                            padding: EdgeInsets.zero,
                            constraints: BoxConstraints(
                                minWidth: screenWidth < 375 ? 24 : 32,
                                minHeight: screenWidth < 375 ? 24 : 32),
                          ),
                          IconButton(
                            icon: Icon(Icons.add,
                                size: screenWidth < 375 ? 18 : 22),
                            onPressed: addTimerRow,
                            padding: EdgeInsets.zero,
                            constraints: BoxConstraints(
                                minWidth: screenWidth < 375 ? 24 : 32,
                                minHeight: screenWidth < 375 ? 24 : 32),
                          ),
                        ],
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
      body: Stack(
        children: [
          // Main timer list content - no sliding, only buttons covered by drawer
          ReorderableListView(
            scrollController: _scrollController,
            buildDefaultDragHandles: true,
            padding: EdgeInsets.zero,
            onReorder: (oldIndex, newIndex) {
              if (mounted) {
                setState(() {
                  if (newIndex > oldIndex) newIndex -= 1;
                  final name = runnerNames.removeAt(oldIndex);
                  final key = rowKeys.removeAt(oldIndex);
                  runnerNames.insert(newIndex, name);
                  rowKeys.insert(newIndex, key);

                  // CRITICAL FIX: Remap timer states after reordering
                  _remapTimerStatesAfterReorder();

                  saveRunnerNames();
                });
              }
            },
            children: [
              for (int index = 0; index < runnerNames.length; index++)
                Container(
                  key: ValueKey('${runnerNames[index]}-$index'),
                  height: rowHeight,
                  child: Builder(
                    builder: (context) {
                      final Color rowColor = index.isOdd
                          ? Colors.white
                          : Color.fromRGBO(254, 205, 146, 1);
                      if (pendingDeleteIndex == index) {
                        return Stack(
                          children: [
                            Positioned.fill(
                              child: Align(
                                alignment: Alignment.centerRight,
                                child: IconButton(
                                  icon: Icon(Icons.delete,
                                      color: Colors.red, size: 32),
                                  onPressed: () {
                                    if (mounted) {
                                      setState(() {
                                        pendingDeleteIndex = null;
                                      });
                                      removeTimerRow(index);
                                    }
                                  },
                                ),
                              ),
                            ),
                            Positioned(
                              left: -60,
                              right: 60,
                              top: 0,
                              bottom: 0,
                              child: GestureDetector(
                                onHorizontalDragEnd: (details) {
                                  if (details.primaryVelocity != null &&
                                      details.primaryVelocity! > 0) {
                                    if (mounted) {
                                      setState(() {
                                        pendingDeleteIndex = null;
                                      });
                                    }
                                  }
                                },
                                child: Container(
                                  color: rowColor,
                                  child: TimerRow(
                                    key: rowKeys[index],
                                    runnerName: runnerNames[index],
                                    rowIndex: index,
                                    scrollController: _scrollController,
                                    rowHeight: rowHeight,
                                    rowColor: rowColor,
                                    timerState: _getTimerState(index),
                                    onNameChanged: (newName) {
                                      _updateRunnerName(index, newName);
                                    },
                                  ),
                                ),
                              ),
                            ),
                          ],
                        );
                      }
                      return GestureDetector(
                        onHorizontalDragEnd: (details) {
                          if (details.primaryVelocity != null &&
                              details.primaryVelocity! < 0) {
                            if (mounted) {
                              setState(() {
                                pendingDeleteIndex = index;
                              });
                            }
                          }
                        },
                        child: AnimatedContainer(
                          duration: Duration(milliseconds: 300),
                          decoration: BoxDecoration(
                            color: rowColor,
                            border: _lastActionTimerId ==
                                    _getTimerStateId(index)
                                ? Border.all(
                                    color:
                                        Color(_getUserColor(_lastActionUserId!))
                                            .withOpacity(0.9),
                                    width: 4,
                                  )
                                : null,
                          ),
                          child: TimerRow(
                            key: rowKeys[index],
                            runnerName: runnerNames[index],
                            rowIndex: index,
                            scrollController: _scrollController,
                            rowHeight: rowHeight,
                            rowColor: rowColor,
                            timerState: _getTimerState(index),
                            onNameChanged: (newName) {
                              _updateRunnerName(index, newName);
                            },
                          ),
                        ),
                      );
                    },
                  ),
                ),
            ],
          ),
          // Slide-out panel - covers only the left button area (about 150px wide)
          AnimatedBuilder(
            animation: _slideAnimation,
            builder: (context, child) {
              // Panel width set to 155px as requested
              final double panelWidth = 155;
              final slideOffset =
                  -panelWidth + (_slideAnimation.value * panelWidth);
              return Transform.translate(
                offset: Offset(slideOffset, 0),
                child: Container(
                  width: panelWidth,
                  height: double.infinity,
                  color: Colors.white,
                  child: _buildSlidePanel(),
                ),
              );
            },
          ),
          // LAP drawer - slides from left
          AnimatedBuilder(
            animation: _lapSlideAnimation,
            builder: (context, child) {
              // Full screen panel
              final double panelWidth = MediaQuery.of(context).size.width;
              final slideOffset =
                  -panelWidth + (_lapSlideAnimation.value * panelWidth);
              return Transform.translate(
                offset: Offset(slideOffset, 0),
                child: Container(
                  width: panelWidth,
                  height: double.infinity,
                  color: Colors.white,
                  child: _buildLapSlidePanel(),
                ),
              );
            },
          ),
          // PACE tab button - only shows when both drawers are closed
          AnimatedBuilder(
            animation: _slideAnimation,
            builder: (context, child) {
              // Only show tab when both drawers are closed
              if (_slideAnimation.value > 0.1 || _lapSlideAnimation.value > 0.1)
                return SizedBox.shrink();

              return Positioned(
                bottom: 60,
                left: 0,
                child: GestureDetector(
                  onTap: toggleSlidePanel,
                  child: Container(
                    width: 28, // Very small width for minimal tab appearance
                    height: 80, // Height that won't cover buttons
                    decoration: BoxDecoration(
                      color: Color.fromRGBO(243, 134, 32, 1),
                      borderRadius: BorderRadius.only(
                        topRight: Radius.circular(8),
                        bottomRight: Radius.circular(8),
                      ),
                    ),
                    child: Center(
                      child: RotatedBox(
                        quarterTurns: 3,
                        child: Text(
                          'PACE',
                          style: TextStyle(
                            color: Colors.white,
                            fontSize: 12,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ),
                    ),
                  ),
                ),
              );
            },
          ),
          // LAP tab button
          AnimatedBuilder(
            animation: _lapSlideAnimation,
            builder: (context, child) {
              if (_slideAnimation.value > 0.1 || _lapSlideAnimation.value > 0.1)
                return SizedBox.shrink();

              return Positioned(
                bottom: 150,
                left: 0,
                child: GestureDetector(
                  onTap: toggleLapSlidePanel,
                  child: Container(
                    width: 28,
                    height: 80,
                    decoration: BoxDecoration(
                      color:
                          Color.fromRGBO(76, 175, 80, 1), // Green color for LAP
                      borderRadius: BorderRadius.only(
                        topRight: Radius.circular(8),
                        bottomRight: Radius.circular(8),
                      ),
                    ),
                    child: Center(
                      child: RotatedBox(
                        quarterTurns: 3,
                        child: Text(
                          'LAPS',
                          style: TextStyle(
                            color: Colors.white,
                            fontSize: 12,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ),
                    ),
                  ),
                ),
              );
            },
          ),
          // Connected users panel (only show if online mode AND user clicked to show)
          if (_isUserListVisible &&
              (_isOnlineMode || _connectedUsers.isNotEmpty))
            Positioned(
              bottom: 80,
              right: 10,
              child: Container(
                constraints: BoxConstraints(maxWidth: 200, maxHeight: 300),
                decoration: BoxDecoration(
                  color: Colors.white,
                  borderRadius: BorderRadius.circular(12),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black26,
                      blurRadius: 8,
                      offset: Offset(0, 2),
                    ),
                  ],
                ),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Container(
                      padding: EdgeInsets.all(8),
                      decoration: BoxDecoration(
                        color: Colors.green,
                        borderRadius: BorderRadius.only(
                          topLeft: Radius.circular(12),
                          topRight: Radius.circular(12),
                        ),
                      ),
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Icon(Icons.people, size: 16, color: Colors.white),
                          SizedBox(width: 4),
                          Text(
                            'Connected Users',
                            style: TextStyle(
                              color: Colors.white,
                              fontSize: 12,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ],
                      ),
                    ),
                    Flexible(
                      child: ListView(
                        shrinkWrap: true,
                        children: [
                          // Current user
                          ListTile(
                            dense: true,
                            leading: CircleAvatar(
                              radius: 12,
                              backgroundColor:
                                  Color(_getUserColor(_currentUserId)),
                              child: Icon(Icons.person,
                                  size: 14, color: Colors.white),
                            ),
                            title: Text(
                              'You',
                              style: TextStyle(
                                  fontSize: 12, fontWeight: FontWeight.bold),
                            ),
                          ),
                          Divider(height: 1),
                          // Other users
                          ..._connectedUsers.entries.map((entry) {
                            return ListTile(
                              dense: true,
                              leading: CircleAvatar(
                                radius: 12,
                                backgroundColor:
                                    Color(_getUserColor(entry.key)),
                                child: Icon(Icons.person,
                                    size: 14, color: Colors.white),
                              ),
                              title: Text(
                                'User ${entry.key.substring(5, 8)}',
                                style: TextStyle(fontSize: 12),
                              ),
                              trailing: IconButton(
                                icon: Icon(Icons.close, size: 16),
                                onPressed: () => _removeUser(entry.key),
                                padding: EdgeInsets.zero,
                                constraints: BoxConstraints(),
                              ),
                            );
                          }).toList(),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            ),
        ],
      ),
    );
  }

  void _updateRunnerName(int index, String newName) {
    // Get the current timer state before name change
    String oldTimerId = _getTimerStateId(index);
    TimerState? currentTimerState = timerStates[oldTimerId];

    // Update the runner name
    runnerNames[index] = newName;

    // Update timer state mapping if timer state exists
    if (currentTimerState != null) {
      String newTimerId = _getTimerStateId(index);

      // Remove old mapping and add new mapping
      timerStates.remove(oldTimerId);
      timerStates[newTimerId] = currentTimerState;
    }

    saveRunnerNames();
  }
}

class LapEntry {
  final String lapTime;
  final String splitTime;
  LapEntry({required this.lapTime, required this.splitTime});
}

class TimerRow extends StatefulWidget {
  final String runnerName;
  final int rowIndex;
  final ScrollController scrollController;
  final double rowHeight;
  final ValueChanged<String>? onNameChanged;
  final Color rowColor;
  final TimerState timerState;

  TimerRow({
    Key? key,
    required this.runnerName,
    required this.rowIndex,
    required this.scrollController,
    required this.rowHeight,
    required this.rowColor,
    required this.timerState,
    this.onNameChanged,
  }) : super(key: key);

  @override
  _TimerRowState createState() => _TimerRowState();
}

class _TimerRowState extends State<TimerRow> {
  bool isEditingName = false;
  late TextEditingController _nameController;
  late FocusNode _nameFocusNode;

  // Use the shared timer state instead of local state
  TimerState get timerState => widget.timerState;

  @override
  void initState() {
    super.initState();
    _nameController = TextEditingController(text: widget.runnerName);
    _nameFocusNode = FocusNode();
    _nameFocusNode.addListener(() {
      if (!_nameFocusNode.hasFocus && isEditingName) {
        _finishEditingName();
      }
    });
  }

  @override
  void dispose() {
    // Only dispose UI-related resources, not the shared timer state
    _nameController.dispose();
    _nameFocusNode.dispose();
    super.dispose();
  }

  void startTimer() {
    // Delegate to parent's centralized timer management
    final parentState = context.findAncestorStateOfType<_TimerListState>();
    parentState?._startTimer(timerState, syncToFirebase: true);
  }

  void stopTimer() {
    // Delegate to parent's centralized timer management
    final parentState = context.findAncestorStateOfType<_TimerListState>();
    parentState?._stopTimer(timerState, syncToFirebase: true);
  }

  void resetTimer() {
    // Delegate to parent's centralized timer management
    final parentState = context.findAncestorStateOfType<_TimerListState>();
    parentState?._resetTimer(timerState, syncToFirebase: true);
  }

  void takeLapTime() {
    // Delegate to parent's centralized timer management
    final parentState = context.findAncestorStateOfType<_TimerListState>();
    parentState?._takeLapTime(timerState, syncToFirebase: true);
  }

  void _finishEditingName() {
    setState(() {
      isEditingName = false;
    });
    if (widget.onNameChanged != null) {
      widget.onNameChanged!(_nameController.text);
    }
  }

  void _showLapTimesDialog() {
    showDialog(
      context: context,
      barrierColor: Colors.transparent,
      builder: (context) => Dialog(
        insetPadding: EdgeInsets.symmetric(horizontal: 24, vertical: 80),
        backgroundColor: Colors.white.withAlpha(238),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        child: LapTimesPage(
          lapEntries: timerState.lapEntries,
          runnerName: _nameController.text,
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final mediaQuery = MediaQuery.of(context);

    final double screenWidth = mediaQuery.size.width;
    final bool isOrangeRow =
        widget.rowColor == Color.fromRGBO(254, 205, 146, 1);
    final Color buttonColor = isOrangeRow
        ? Colors.white
        : (timerState.isRunning
            ? Colors.deepOrange[300]!
            : const Color.fromRGBO(243, 134, 32, 1));
    final Color buttonTextColor = isOrangeRow ? Colors.black : Colors.white;

    // Current lap timer color: red on white rows, black on orange rows
    final Color currentLapTimerColor = isOrangeRow ? Colors.black : Colors.red;

    // Responsive flex ratios to give more space to name on small screens
    final int nameFlex =
        screenWidth < 375 ? 2 : 1; // More space for name on small screens
    final int timerSectionFlex =
        screenWidth < 375 ? 3 : 2; // Adjusted proportionally

    // Responsive font sizes based on screen width and row height - optimized for 8-row display
    // Balanced sizing: main timer still largest, lap times significantly larger but proportional
    final double mainTimerFontSize = screenWidth < 375
        ? (widget.rowHeight * 0.30)
            .clamp(22.0, 32.0) // Slightly increased for better visibility
        : screenWidth <
                415 // iPhone 14 Pro Max is 430px, regular iPhone 14 is 390px
            ? (widget.rowHeight * 0.34)
                .clamp(26.0, 38.0) // Increased for better balance
            : (widget.rowHeight * 0.36)
                .clamp(30.0, 42.0); // Increased for larger screens

    final double nameFontSize =
        screenWidth < 375 ? 15.0 : 17.0; // Keep name font size unchanged
    final double lapNumberFontSize = screenWidth < 375
        ? 11.0
        : screenWidth < 415
            ? 12.0
            : 13.0; // Increased for better visibility
    final double lapTimeFontSize = screenWidth < 375
        ? 19.0
        : screenWidth < 415
            ? 22.0
            : 24.0; // Significantly increased, closer to main timer

    // Optimize flex ratios to better utilize space
    final int timerFlex =
        screenWidth < 375 ? 2 : 3; // More space for main timer
    final int lapFlex = screenWidth < 375 ? 2 : 2; // More space for lap times
    //final Color buttonColor = isRunning ? Colors.deepOrange[300]! : Colors.orange[200]!;

    // Portrait layout only (landscape mode disabled)
    return Container(
      decoration: BoxDecoration(),
      padding: EdgeInsets.symmetric(vertical: 0.0, horizontal: 8.0),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Add left margin to avoid overlap with PACE tab
          SizedBox(width: 25), // Space to avoid PACE tab overlap
          // Start/Stop and Lap/Reset buttons
          Padding(
            padding: const EdgeInsets.symmetric(vertical: 8.0),
            child: SizedBox(
              width: 60,
              height: 80,
              child: ElevatedButton(
                style: ElevatedButton.styleFrom(
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(12),
                  ),
                  padding: EdgeInsets.zero,
                  backgroundColor: buttonColor,
                ),
                onPressed: () async {
                  // Use comprehensive haptic feedback but don't block the timer action
                  performHapticFeedback(); // Remove await to not block the action

                  if (timerState.isRunning) {
                    stopTimer();
                  } else {
                    startTimer();
                  }
                },
                child: Text(
                  timerState.isRunning ? 'Stop' : 'Start',
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                    color: buttonTextColor,
                  ),
                ),
              ),
            ),
          ),
          SizedBox(width: 8),
          Padding(
            padding: const EdgeInsets.symmetric(vertical: 8.0),
            child: SizedBox(
              width: 60,
              height: 80,
              child: ElevatedButton(
                style: ElevatedButton.styleFrom(
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(12),
                  ),
                  padding: EdgeInsets.zero,
                  backgroundColor: buttonColor,
                ),
                onPressed: () async {
                  // Use comprehensive haptic feedback but don't block the reset action
                  performHapticFeedback(); // Remove await to not block the action

                  if (timerState.isRunning) {
                    takeLapTime();
                  } else {
                    resetTimer();
                  }
                },
                child: Text(
                  timerState.isRunning ? 'Lap' : 'Reset',
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                    color: buttonTextColor,
                  ),
                ),
              ),
            ),
          ),
          SizedBox(width: 16),
          // Right side content area
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Top row: Runner name with responsive sizing and proper vertical space
                Expanded(
                  flex: nameFlex, // More space on small screens
                  child: Padding(
                    padding: EdgeInsets.symmetric(
                        vertical: screenWidth < 375
                            ? 1.0
                            : 4.0), // Minimal padding to maximize text space
                    child: GestureDetector(
                      onTap: () async {
                        setState(() {
                          isEditingName = true;
                        });
                        await Future.delayed(Duration(milliseconds: 100));
                        _nameFocusNode.requestFocus();
                        widget.scrollController.animateTo(
                          widget.rowIndex * widget.rowHeight,
                          duration: Duration(milliseconds: 300),
                          curve: Curves.easeInOut,
                        );
                      },
                      child: Container(
                        width: double.infinity,
                        height: double.infinity, // Use full available height
                        alignment: Alignment.centerLeft,
                        color: Colors.transparent,
                        child: isEditingName
                            ? TextField(
                                controller: _nameController,
                                focusNode: _nameFocusNode,
                                autofocus: true,
                                textAlign: TextAlign.left,
                                onSubmitted: (_) {
                                  _finishEditingName();
                                },
                                decoration: InputDecoration(
                                  border: InputBorder.none,
                                  isDense: true,
                                  contentPadding: EdgeInsets
                                      .zero, // Remove all padding for more space
                                ),
                                style: TextStyle(
                                  fontSize:
                                      nameFontSize, // Responsive font size
                                  fontWeight: FontWeight.normal,
                                  color: Colors.black,
                                  height:
                                      1.2, // Proper line height to prevent clipping
                                ),
                              )
                            : Container(
                                width: double.infinity,
                                height: double.infinity,
                                alignment: Alignment.centerLeft,
                                child: Text(
                                  _nameController.text.isEmpty
                                      ? ' '
                                      : _nameController.text,
                                  style: TextStyle(
                                    fontSize:
                                        nameFontSize, // Same font size as TextField
                                    fontWeight: FontWeight.normal,
                                    color: Colors.black,
                                    height:
                                        1.2, // Proper line height to prevent vertical clipping
                                  ),
                                  maxLines: 1,
                                  overflow: TextOverflow
                                      .ellipsis, // Use ellipsis instead of scaling
                                  textAlign: TextAlign.left,
                                ),
                              ),
                      ),
                    ),
                  ),
                ),
                // Bottom row: Timer value (large) and lap times (smaller)
                Expanded(
                  flex:
                      timerSectionFlex, // Adjusted flex for better proportions
                  child: Row(
                    crossAxisAlignment: CrossAxisAlignment.center,
                    children: [
                      // Left column: Main timer value (larger font)
                      Expanded(
                        flex:
                            timerFlex, // More space for timer on larger screens
                        child: Padding(
                          padding: EdgeInsets.symmetric(
                              vertical: screenWidth < 375
                                  ? 2.0
                                  : 1.0, // Reduced padding for more space
                              horizontal: 1.0 // Reduced horizontal padding
                              ),
                          child: FittedBox(
                            fit: BoxFit.scaleDown,
                            child: Text(
                              timerState.timerValue,
                              style: TextStyle(
                                fontSize:
                                    mainTimerFontSize, // Responsive font size
                                fontFamily: 'Courier',
                                height: 1,
                                fontWeight: FontWeight.bold,
                                color: Colors.black,
                              ),
                              maxLines: 1,
                              textAlign: TextAlign.center,
                            ),
                          ),
                        ),
                      ),
                      // Right column: Current lap and last 2 lap times (smaller fonts)
                      Expanded(
                        flex: lapFlex, // Responsive flex for lap times
                        child: Column(
                          crossAxisAlignment:
                              CrossAxisAlignment.end, // Align to right
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            // Current lap number and timer
                            Padding(
                              padding: EdgeInsets.symmetric(
                                  vertical: screenWidth < 375
                                      ? 0.5
                                      : 0.5, // Reduced vertical padding
                                  horizontal: screenWidth < 375
                                      ? 2.0
                                      : 1.0 // Reduced horizontal padding
                                  ),
                              child: Row(
                                mainAxisAlignment: MainAxisAlignment
                                    .end, // Align row content to right
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  // Fixed width for lap number to maintain alignment
                                  SizedBox(
                                    width: screenWidth < 375
                                        ? 18
                                        : 20, // Fixed width for consistent alignment
                                    child: Text(
                                      '${timerState.currentLapNumber}',
                                      style: TextStyle(
                                        fontSize:
                                            lapNumberFontSize, // Responsive font size
                                        fontWeight: FontWeight.bold,
                                        color:
                                            currentLapTimerColor, // Use dynamic color based on row
                                        fontFamily: 'Courier',
                                        height: 1,
                                      ),
                                      textAlign: TextAlign
                                          .right, // Right align within fixed width
                                    ),
                                  ),
                                  SizedBox(width: 1), // Reduced spacing
                                  Flexible(
                                    child: FittedBox(
                                      fit: BoxFit.scaleDown,
                                      alignment: Alignment.centerRight,
                                      child: Text(
                                        timerState.currentLapTimeValue,
                                        style: TextStyle(
                                          fontSize:
                                              lapTimeFontSize, // Responsive font size
                                          fontWeight: FontWeight.bold,
                                          color:
                                              currentLapTimerColor, // Use dynamic color based on row
                                          fontFamily: 'Courier',
                                          height: 1,
                                        ),
                                        maxLines: 1,
                                        textAlign: TextAlign.right,
                                      ),
                                    ),
                                  ),
                                ],
                              ),
                            ),
                            // Last two lap rows
                            if (timerState.lapEntries.isNotEmpty) ...[
                              for (var i = 0;
                                  i < timerState.lapEntries.length && i < 2;
                                  i++)
                                Padding(
                                  padding: EdgeInsets.symmetric(
                                      vertical: screenWidth < 375
                                          ? 0.5
                                          : 0.5, // Reduced vertical padding
                                      horizontal: screenWidth < 375
                                          ? 2.0
                                          : 1.0 // Reduced horizontal padding
                                      ),
                                  child: GestureDetector(
                                    onTap: _showLapTimesDialog,
                                    child: Row(
                                      mainAxisAlignment: MainAxisAlignment
                                          .end, // Align row content to right
                                      mainAxisSize: MainAxisSize.min,
                                      children: [
                                        // Fixed width for lap number to maintain alignment
                                        SizedBox(
                                          width: screenWidth < 375
                                              ? 18
                                              : 20, // Fixed width for consistent alignment
                                          child: Text(
                                            '${timerState.lapEntries.length - i}',
                                            style: TextStyle(
                                              fontSize:
                                                  lapNumberFontSize, // Responsive font size
                                              fontWeight: FontWeight.bold,
                                              color: Colors.black,
                                              fontFamily: 'Courier',
                                              height: 1,
                                            ),
                                            textAlign: TextAlign
                                                .right, // Right align within fixed width
                                          ),
                                        ),
                                        SizedBox(width: 1), // Reduced spacing
                                        Flexible(
                                          child: FittedBox(
                                            fit: BoxFit.scaleDown,
                                            alignment: Alignment.centerRight,
                                            child: Text(
                                              timerState.lapEntries[i].lapTime,
                                              style: TextStyle(
                                                fontSize:
                                                    lapTimeFontSize, // Responsive font size
                                                fontWeight: FontWeight.bold,
                                                color: Colors.black,
                                                fontFamily: 'Courier',
                                                height: 1,
                                              ),
                                              maxLines: 1,
                                              textAlign: TextAlign.right,
                                            ),
                                          ),
                                        ),
                                      ],
                                    ),
                                  ),
                                ),
                            ],
                          ],
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

class LapTimesPage extends StatelessWidget {
  final List<LapEntry> lapEntries;
  final String runnerName;

  LapTimesPage({required this.lapEntries, required this.runnerName});

  @override
  Widget build(BuildContext context) {
    final mediaQuery = MediaQuery.of(context);
    final double screenWidth = mediaQuery.size.width;

    // More aggressive font size reduction for iPhone 13 mini to ensure single-line fit
    final double titleFontSize = screenWidth < 375 ? 16.0 : 18.0;
    final double lapTextFontSize =
        screenWidth < 375 ? 10.0 : 14.0; // Reduced for small screens

    List<int> lapMillis = lapEntries
        .map((e) => _parseDuration(e.lapTime).inMilliseconds)
        .toList();
    int? maxLap =
        lapMillis.isNotEmpty ? lapMillis.reduce((a, b) => a > b ? a : b) : null;
    int? minLap =
        lapMillis.isNotEmpty ? lapMillis.reduce((a, b) => a < b ? a : b) : null;

    return Padding(
      padding: EdgeInsets.all(screenWidth < 375 ? 12.0 : 16.0),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Row(
            children: [
              Expanded(
                child: Text(
                  '$runnerName Lap Times',
                  style: TextStyle(
                      fontSize: titleFontSize, fontWeight: FontWeight.bold),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
              ),
              IconButton(
                icon: Icon(Icons.close, size: screenWidth < 375 ? 20 : 24),
                onPressed: () => Navigator.of(context).pop(),
                padding: EdgeInsets.zero,
                constraints: BoxConstraints(
                  minWidth: screenWidth < 375 ? 32 : 40,
                  minHeight: screenWidth < 375 ? 32 : 40,
                ),
              ),
            ],
          ),
          Divider(),
          SizedBox(
            height: 300, // Set a fixed height for scrollable list
            child: ListView.builder(
              shrinkWrap: true,
              itemCount: lapEntries.length,
              itemBuilder: (context, index) {
                final entry = lapEntries[index];
                final lapMs = lapMillis[index];
                Color? tileColor;
                if (lapMs == maxLap) tileColor = Colors.red[100];
                if (lapMs == minLap) tileColor = Colors.green[100];
                return ListTile(
                  tileColor: tileColor,
                  dense: true, // Always dense for consistent height
                  isThreeLine: false,
                  contentPadding: EdgeInsets.symmetric(
                    horizontal: screenWidth < 375
                        ? 6.0
                        : 16.0, // Reduced padding on small screens
                    vertical: screenWidth < 375
                        ? 2.0
                        : 4.0, // Minimal vertical padding
                  ),
                  title: LayoutBuilder(
                    builder: (context, constraints) {
                      // Calculate available width for text, reserving space for badge if needed
                      double availableWidth = constraints.maxWidth;
                      bool hasBadge = (lapMs == maxLap || lapMs == minLap);
                      double badgeWidth =
                          hasBadge ? (screenWidth < 375 ? 24 : 30) : 0;
                      double spacing = hasBadge ? 4 : 0;
                      double textWidth = availableWidth - badgeWidth - spacing;

                      String displayText =
                          'Lap ${lapEntries.length - index}: ${entry.lapTime}   Split: ${entry.splitTime}';

                      return Row(
                        crossAxisAlignment: CrossAxisAlignment.center,
                        children: [
                          // Simple FittedBox solution for reliable single-line scaling
                          SizedBox(
                            width: textWidth,
                            height: 20, // Fixed height for consistency
                            child: FittedBox(
                              fit: BoxFit.scaleDown,
                              alignment: Alignment.centerLeft,
                              child: Text(
                                displayText,
                                style: TextStyle(
                                    fontSize: lapTextFontSize,
                                    fontWeight: FontWeight.bold),
                                maxLines: 1,
                                overflow: TextOverflow.visible,
                              ),
                            ),
                          ),
                          // Compact badge
                          if (hasBadge) ...[
                            SizedBox(width: 4),
                            Container(
                              width: screenWidth < 375 ? 20 : 26,
                              height: screenWidth < 375 ? 14 : 16,
                              decoration: BoxDecoration(
                                color:
                                    lapMs == maxLap ? Colors.red : Colors.green,
                                borderRadius: BorderRadius.circular(
                                    screenWidth < 375 ? 2 : 3),
                              ),
                              child: Center(
                                child: Text(
                                  lapMs == maxLap ? 'Min' : 'Max',
                                  style: TextStyle(
                                    color: Colors.white,
                                    fontSize: screenWidth < 375 ? 6 : 7,
                                    fontWeight: FontWeight.bold,
                                  ),
                                ),
                              ),
                            ),
                          ],
                        ],
                      );
                    },
                  ),
                  trailing:
                      null, // No trailing needed since badge is integrated
                );
              },
            ),
          ),
        ],
      ),
    );
  }

  Duration _parseDuration(String timeString) {
    final parts = timeString.split(':');
    final minutes = int.parse(parts[0]);
    final seconds = int.parse(parts[1]);
    final hundredths = int.parse(parts[2]);
    return Duration(
        minutes: minutes, seconds: seconds, milliseconds: hundredths * 10);
  }
}
